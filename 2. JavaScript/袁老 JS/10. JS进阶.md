# 十、JS进阶

问题:
1. 事件队列和事件循环没理解;
2. 对圣杯模式理解 以及 相关继承发展史的认识;
3. 函数防抖部分 有一个问题 this的指向没理解;
4. 回顾正则表达式的相关知识点;

## 1. 原型和原型链

- 所有对象都是通过```new 函数```创建
- 所有的函数也是对象`函数对象是通过 new Function() 来创建的`
  - 函数中可以有属性
- 所有对象都是引用类型

### 原型 `prototype`

所有函数都有一个属性：`prototype`，称之为函数原型

默认情况下，`prototype`是一个普通的`Object对象`

默认情况下，`prototype`中有一个属性，`constructor`，它也是一个对象，它指向构造函数本身。

### 隐式原型 `__proto__`

所有的对象都有一个属性：```__proto__```，称之为隐式原型

**默认情况下，隐式原型指向创建该对象的函数的原型。**

当访问一个对象的成员时：

1. 看该对象自身是否拥有该成员，如果有直接使用
2. 在原型链中依次查找是否拥有该成员，如果有直接使用

> 猴子补丁：在函数原型中加入成员，以增强起对象的功能，猴子补丁会导致原型污染，使用需谨慎。

### 原型链

特殊点：

1. Function的`__proto__`指向自身的prototype`因为没有构造函数来创建Function，Function是直接丢内存里的，所以它的隐式原型比较特殊，指向自身的原型Function.prototype。`
2. Object的prototype的`__proto__`指向null`因为Object.prototype可以说是原型链的终点了，它不在有父类。`

### 参考图

- 函数是通过new Function创建的

![20210226111559](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210226111559.png)

- 普通对象是通过 `new 函数` 创建的

![20210226111615](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210226111615.png)

- 每个函数都有原型对象

![20210226111630](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210226111630.png)

- 原型中的constructor指向函数本身

![20210226111646](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210226111646.png)

- 隐式原型的指向

![20210226111704](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210226111704.png)

- 链条的全貌

![20210226111726](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210226111726.png)

### test.html

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <title>0-20min</title>
</head>

<body>
    <script>
        function test() {}
        var obj = new test();
        // 原型中的属性 constructor 指向创建该原型的构造函数
        console.log(test.prototype.constructor === test); // true
        // 实例中的属性 __proto__ 指向创建该实例的函数的原型
        console.log(obj.__proto__ === test.prototype); // true
    </script>

    <script>
        function test() {
            // var this = { __proto__: test.prototype }
            return {}; // return new Object();
            // return this; // 由于在此之前有一条return语句 并且返回的是一个对象 所以该语句被覆盖
        }

        var obj = new test(); // 此时obj实际上是由 Object 构造函数所创建的一个实例对象
        console.log(obj.__proto__ === Object.prototype); // true
    </script>
</body>

</html>
```

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <title>20-25min</title>
</head>

<body>
    <script>
        // 面试题 ==> 如何得到创建obj的构造函数名称?
        function A() {}

        function B() {}

        function create() {
            if (Math.random() < 0.5) {
                return new A();
            } else {
                return new B();
            }
        }

        var obj = create();
        // 1 .通过实例的属性 __proto__ 来访问原型对象
        // 2 .再通过原型对象的属性 constructor 来访问构造函数
        // 3 .最后通过函数的属性 name 即可获取构造函数的函数名
        console.log(obj.__proto__.constructor.name);
    </script>
</body>

</html>
```

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <title>25min-30min</title>
</head>

<body>
    <script>
        // 面试题
        function A() {}

        var obj1 = new A();
        var obj2 = new A();
        obj1.abc = 123;
        obj2.__proto__.bcd = 456;
        // obj1 和 obj2 共享一个原型对象 ==> A.prototype

        console.log(obj1.abc, obj2.abc); // 123 undefined
        console.log(obj1.__proto__.bcd, obj2.__proto__.bcd); // 456 456
    </script>
</body>

</html>
```

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <title>30min-60min</title>
</head>

<body>
    <script>
        function User(name, age) {
            this.name = name;
            this.age = age;
        }

        /* 将所有实例对象共享的东西 (特别是函数) 放在构造函数的原型上 */
        User.prototype.sayHello = function () {
            // var this = { __proto__: User.prototype }
            console.log(this.name, this.age);
            // return this;
        }

        var u1 = new User("abc", 11);
        var u2 = new User("bcd", 12);

        console.log(u1.sayHello === u2.sayHello); // true
    </script>

    <!-- <script>
        // 正则表达式 没看懂 先跳过
        // 转驼峰
        String.prototype.camel = function () {
            return this.replace(/\b(\w)(\w*)\b/g, function ($, $1, $2) {
                // console.log($, $1, $2);  // 会输出3次
                return $1.toUpperCase() + $2;
            }).replace(/\s/g, "");
        }

        console.log("sbdf asdger rdg".camel()); // "SbdfAsdgerRdg"
    </script> -->
</body>

</html>
```

三道面试题

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>面试题1-3 60min-70min</title>
</head>

<body>
    <script>
        // T1
        var F = function () {}
        Object.prototype.a = function () {} // fn1
        Function.prototype.b = function () {} // fn2

        var f = new F();

        console.log(f.a, f.b, F.a, F.b); // f.a === F.a
        // fn1    undefined    fn1    fn2

        /* 先来理一下涉及到的原型链 */
        // f ==> F.prototype ==> Object.prototype
        // F ==> Function.prototype ==> Object.prototype

        /* 以下是详细分析过程 */
        // f.a ==> Object.prototype.a
        /* 查找过程如下:
        1. 到 f.__proto__ (即实例f的构造函数的原型对象 F.prototype) 上找 属性a 结果 没有找到 继续查找;
        2. 到 f.__proto__ 的原型 (即 F.prototype.__proto__ ) 上找 属性a 实际上也就是到 Object.prototype 上找属性a 找到了 Object.prototype.a */

        // f.b ==> undefined
        /* 查找过程如下:
        1. 到 f.__proto__ (即实例f的构造函数的原型对象 F.prototype) 上找 属性b 结果 没有找到 继续查找;
        2. 到 f.__proto__ 的原型 (即 F.prototype.__proto__ ) 上找 属性b 实际上也就是到 Object.prototype 上找属性b 依旧没找到;
        3. 已经到头了 不再继续查找 返回 undefined; */

        // F.a ==> Object.prototype.a
        /* 查找过程如下:
        1. 到 F.__proto__ (即实例F的构造函数的原型对象 Function.prototype) 上找 属性a 结果 没有找到 继续查找; [注意: 所有的函数都可以看做是 Function() 函数的实例对象]
        2. 到 F.__proto__ 的原型 (即 Function.prototype.__proto__ ) 上找 属性a 实际上也就是到 Object.prototype 上找属性a 找到了 Object.prototype.a */

        // F.b ==> Function.prototype.b
        /* 查找过程如下:
        1. 到 F.__proto__ (即实例F的构造函数的原型对象 Function.prototype) 上找 属性b 结果 找到了 Function.prototype.b; */
    </script>

    <script>
        // T2
        function A() {}

        function B(a) {
            this.a = a; // 若利用构造函数B来创建实例对象 并且 没有传入参数的情况下 那么实例的属性a的值是 undefined 也就是说 由构造函数B创建的实例对象中必然带有属性a 要么是调用构造函数时传入的值 要么就是undefined 当访问该属性时 由于自身带有 所以就不会沿着原型链去查找了
            // 这里有涉及到一部分执行上下文的知识点
            // 函数B的AO对象中有一个属性(参数)a 在没有传入值的情况下
            // 该属性的值默认是 undefined
        }

        function C(a) {
            if (a) { // 如果a有值
                this.a = a; // 那么将 传入的a的值 赋值给由此构造函数创建的实例对象上的属性a
            }
        }
        A.prototype.a = 1;
        B.prototype.a = 1;
        C.prototype.a = 1;

        console.log(new A().a); // 1
        console.log(new B().a); // undefined
        console.log(new C(2).a); // 2
    </script>

    <script>
        // T3 ==> 袁老出的面试题 能看懂基本上原型这一块就没啥问题了
        function User() {}
        User.prototype.sayHello = function () {}

        var u1 = new User();
        var u2 = new User();

        console.log(u1.sayHello === u2.sayHello); // true
        console.log(User.prototype.constructor); // f User() {}
        console.log(User.prototype === Function.prototype); // false
        console.log(User.__proto__ === Function.prototype); // true
        console.log(User.__proto__ === Function.__proto__); // true
        // 注意 Function.prototype 和 Function.__proto__ 是一个东西 这是一个特殊情况
        console.log(u1.__proto__ === u2.__proto__); // true
        console.log(u1.__proto__ === User.__proto__); // false
        console.log(Function.__proto__ === Object.__proto__); // true
        console.log(Function.prototype.__proto__ === Object.prototype.__proto__); // false
        console.log(Function.prototype.__proto__ === Object.prototype); // true
    </script>
</body>

</html>
```


## 2. 原型链的应用

### 基础方法

W3C不推荐直接使用系统成员__proto__

**Object.getPrototypeOf(对象)**

获取对象的隐式原型

**Object.prototype.isPrototypeOf(对象)**

判断当前对象(this)是否在指定对象的原型链上

**对象 instanceof ==函数==**

判断函数的原型是否在对象的原型链上

**Object.create(对象)**

创建一个新对象，其隐式原型指向指定的对象

**Object.prototype.hasOwnProperty(属性名)**

判断一个对象**自身**是否拥有某个属性

### 应用

**类数组转换为真数组**

```js
Array.prototype.slice.call(类数组);
```

**实现继承**

默认情况下，所有构造函数的父类都是Object

==圣杯模式== ==> 一定得会写 很重要

[JavaScript 继承模式发展史](https://blog.csdn.net/Yuki_yuhan/article/details/108248086?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control)

[JS 圣杯模式](http://www.mamicode.com/info-detail-2373240.html)

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>继承发展史</title>
</head>

<body>
    <script>
        /* 1. 原型链（传统模式） */
        Father.prototype.lastName = 'wang';

        function Father() {
            this.name = "dad";
        }
        var father = new Father();
        Son.prototype = father;

        function Son() {}
        var son = new Son(); // 子类所创建的实例 son

        // 1. 实现了继承
        console.log(son.lastName); // wang
        // 2. 但是继承了过多没用的属性
        console.log(son.name); // dad

        /* 直接将 子类构造函数 Son的原型 指向 父类构造函数 Father的原型所创建的实例对象上
        优点：父类的方法和属性得到了复用，并在子类中修改属性是不会影响到父类们的。
        缺点：过多的继承了没用的属性。 */
    </script>
    <script>
        /* 2. 借用构造函数 */
        function Person(name, age) {
            this.name = name;
            this.age = age;
        }

        function Student(name, age, grade) {
            Person.call(this, name, age);
            this.grade = grade;
        }
        var stu = new Student();
        // 1. 没有实现继承
        Person.prototype.lastName = "duyi";
        console.log(stu.lastName); // undefined
        /* 在子类构造函数的内部调用父类构造函数
        优点：解决原型中包含引用类型值所带来的问题，还可以传递参数。并且子类的每个实例都有自己的属性，不会相互影响。
        缺点：不能继承借用构造函数的原型，每次构造函数都要多走一个函数。 */
    </script>
    <script>
        /* 3. 共享原型 */
        Father.prototype.lastName = 'wang'

        function Father() {}

        function Son() {}
        Son.prototype = Father.prototype;

        var son = new Son();
        var father = new Father();
        // 1. 没有实现继承 实现的是共享
        Son.prototype.sex = "meal";
        console.log(son.lastName, father.lastName); // wang wang
        console.log(son.sex, father.sex); // meal meal

        /* 采用 Son.prototype = Father.prototype; 的方式 让son和father的原型都指向同一个空间
        即不管改变两者之中的哪一个 另一个也会跟着改变
        优点: 写法简单
        缺点: 子类无法随意修改自己的原型 实现的是共享效果 而非继承效果 */
    </script>
    <script>
        // 圣杯模式写法1：
        // function inherit(target, origin) {
        //     function F() {};
        //     F.prototype = origin.prototype;
        //     target.prototype = new F();
        //     target.prototype.constructor = target;
        //     target.prototype.uber = origin.prototype;
        // }
        // 圣杯模式写法2：
        var inherit = (function () {
            // 采用闭包方式实现封装和属性私有化
            var F = function () {};
            return function (Target, Origin) {
                F.prototype = Origin.prototype;
                Target.prototype = new F(); // objF
                Target.prototype.constructor = Target;
                Target.prototype.uber = Origin.prototype;
            }
        }());

        Father.prototype.lastName = 'wang';

        function Father() {}

        function Son() {}
        inherit(Son, Father);
        var son = new Son();
        var father = new Father();
        // 1. 实现了继承 并且 子类有自己的原型(不是和父类共用一个原型)
        Son.prototype.sex = "meal"; // 这个属性 实际上是添加到了 中间实例对象 objF 中 所以并不会对父类造成影响
        console.log(son.lastName, father.lastName); // wang wang
        console.log(son.sex, father.sex); // meal undefined
    </script>
</body>

</html>
```


### test.html

**Simplified version**

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>原型链的应用 - 基础方法</title>
</head>

<body>
    <script>
        var obj = {};
        console.log(obj.getPrototypeOf); // undefined
        console.log(obj.__proto__ === Object.getPrototypeOf(obj)); // true
        console.log(obj.__proto__.constructor.name); // "Object"
        console.log(Object.getPrototypeOf(obj).constructor.name); // "Object"
    </script>

    <script>
        function A() {}
        var obj = new A();
        console.log(Object.prototype.isPrototypeOf(obj)); // true
        console.log(Function.prototype.isPrototypeOf(obj)); // false

        var o = {};
        console.log(o.isPrototypeOf(obj)); // false
        console.log(Object.getPrototypeOf(o).isPrototypeOf(obj)); // true

        var arr = [];
        console.log(Array.isArray(arr)); // true
        console.log(Array.prototype.isPrototypeOf(arr)); // true
        console.log(arr instanceof Array); // true
    </script>

    <script>
        var obj = {};
        console.log(obj instanceof Object); // true
        console.log([] instanceof Array); // true
    </script>

    <script>
        var obj = {};

        var p = {
            x: 1,
            y: 2
        };

        var obj1 = Object.create(p);
        console.log(obj1.x, obj1.y); // 1 2
        console.log(obj1.constructor === Object); // true
        console.log(obj1.constructor === Object.prototype.constructor); // true

        var obj2 = Object.create(null);
        console.dir(obj2); // Object No properties
    </script>

    <script>
        var p = {
            x: 1,
            y: 2
        }
        var obj1 = Object.create(p);
        console.log(p.x,p.hasOwnProperty("x")); // 1 true
        console.log(obj1.x,obj1.hasOwnProperty("x")); // 1 false
    </script>
</body>

</html>
```

**Include annotated version**

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>原型链的应用 - 基础方法</title>
</head>

<body>
    <script>
        /* 0min-5min */
        // 1. Object.getPrototypeOf(对象) ==> 获取对象的隐式原型
        // 注意点 ==> 1. getPrototypeOf 这个方法是 Object函数 上的方法; ==> getPrototypeOf 是一个静态成员
        var obj = {}; // 普通对象上没有 getPrototypeOf 这个方法
        console.log(obj.getPrototypeOf); // undefined

        console.log(obj.__proto__ === Object.getPrototypeOf(obj)); // true
        // 由于W3C不推荐直接使用系统成员 __proto__ 所以我们可以使用它的上面这种等效写法
        // 不推荐的原因有很多 一方面影响性能  也很有可能之后就直接禁止使用系统成员也说不定
        console.log(obj.__proto__.constructor.name); // "Object"
        console.log(Object.getPrototypeOf(obj).constructor.name); // "Object"
    </script>

    <script>
        /* 5min-10min */
        // 2. Object.prototype.isPrototypeOf(对象) ==> 判断当前对象(this)是否在指定对象的原型链上
        // Object.prototype 后面跟的 是 实例成员 ==> 所有对象实例都可以使用

        function A() {}
        let obj = new A();
        console.log(Object.prototype.isPrototypeOf(obj)); // true
        // 说明 ==> 判断 Object.prototype 是否在 obj 的原型链上
        // obj的原型链:
        // obj ==>
        // A.prototype(obj.__proto__) ==>
        // A.prototype.__proto__(obj.__proto__.__proto__ 也就是 Object.prototype)
        // 最后是 null
        console.log(Function.prototype.isPrototypeOf(obj)); // false

        var o = {};
        console.log(o.isPrototypeOf(obj)); // false
        console.log(Object.getPrototypeOf(o).isPrototypeOf(obj)); // true

        // 补充: 在之前没有 Array.isArray(arr) 方法, 通常用来 Array.prototype.isPrototypeOf(arr)
        // arr instanceof Array ==> 也可以用来判断是否是数组 不过不推荐使用 (如果页面上没有 iframe 元素 那么大胆的用 否则可能会出问题)
        // 上面提到判断是否是数组的方式 了解即可 我们后面在实际开发的时候 直接使用 Array.isArray(arr) 就OK
    </script>

    <script>
        /* 10min-11min */
        // 3. 对象 instanceof 函数 ==> 判断函数的原型是否在对象的原型链上
        let obj = {};
        console.log(obj instanceof Object); // true
        console.log([] instanceof Array); // true
    </script>

    <script>
        // 4. Object.create(对象) ==> 创建一个新对象，其隐式原型指向指定的对象
        let obj = {};
        // 等效写法: let obj = Object.create(Object.prototype);
        // 创建一个新对象 obj
        // 新对象 obj 的隐式原型 obj.__proto__ 指向 指定对象 Object.prototype
        let p = {
            x: 1,
            y: 2
        }
        let obj1 = Object.create(p);
        console.log(obj1.x, obj1.y); // 1 2
        console.log(obj1.constructor === Object); // true
        console.log(obj1.constructor === Object.prototype.constructor); // true

        let obj2 = Object.create(null); // [面试题] 并非所有的对象都以 Object.prototype 为原型链的终点
        console.dir(obj2); // Object No properties
    </script>

    <script>
        // 5. Object.prototype.hasOwnProperty(属性名) ==> 判断一个对象自身是否拥有某个属性
        // 注意 属性名要以字符串的形式传入
        let p = {
            x: 1,
            y: 2
        }
        let obj1 = Object.create(p);
        console.log(p.hasOwnProperty("x")); // true
        console.log(obj1.hasOwnProperty("x")); // false
    </script>
</body>

</html>
```

**Simplified version**

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> 原型链的应用 - 应用 </title>
</head>

<body>
    <script>
        var p = {
            x: 123,
            y: 456
        };

        var obj = Object.create(p);
        obj.abc = "656432434af";

        for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
                console.log(prop); // "abc"
            }
        }

        for (var prop in obj) {
            console.log(prop); // "abc" "x" "y"
        }
    </script>

    <script>
        function User(firstName, lastName, age) {
            this.firstName = firstName;
            this.lastName = lastName;
            this.age = age;
            this.fullName = this.firstName + " " + this.lastName;
        }

        User.prototype.sayHello = function () {
            console.log(`大家好，我叫${this.fullName}，今年${this.age}岁了`);
        }

        function VIPUser(firstName, lastName, age, money) {
            User.call(this, firstName, lastName, age);
            this.money = money;
        }

        VIPUser.prototype.upgrade = function () {
            console.log(`使用了${100}元软妹币，升级了！`);
            this.money -= 100;
        }

        var vUser = new VIPUser("姬", "成", 1, 100);
    </script>

    <script>
        myPlugin.inherit = function (son, father) {
            son.prototype = Object.create(father.prototype)
            son.prototype.constructor = son;
            son.prototype.uber = father.prototype;
            // son.prototype.uber = father;
        }

        function User(firstName, lastName, age) {
            this.firstName = firstName;
            this.lastName = lastName;
            this.age = age;
            this.fullName = this.firstName + " " + this.lastName;
        }

        User.prototype.sayHello = function () {
            console.log(`大家好，我叫${this.fullName}，今年${this.age}岁了`);
        }

        function VIPUser(firstName, lastName, age, money) {
            // this.uber(firstName, lastName, age);
            User.call(this, firstName, lastName, age);
            this.money = money;
        }

        myPlugin.inherit(VIPUser, User);

        VIPUser.prototype.upgrade = function () {
            console.log(`使用了${100}元软妹币，升级了！`);
            this.money -= 100;
        }

        var vUser = new VIPUser("姬", "成", 1, 100);
    </script>
</body>

</html>
```

**Include annotated version**

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> 原型链的应用 - 应用 </title>
</head>

<body>
    <script>
        var p = {
            x: 123,
            y: 456
        };

        var obj = Object.create(p);
        obj.abc = "656432434af";
        // 只打印出自身带有的属性和方法 忽略继承过来的
        for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
                console.log(prop);
            }
        }

        for (var prop in obj) {
            console.log(prop); // 发现这里并不会打印 Object.prototype 上的属性和方法
            // 涉及到后面要讲的属性描述符相关的知识点
        }
    </script>

    <script>
        // 应用1 ==> 类数组转换为真数组
        // ES6 ==> Array.from(类数组)
        // ES6以前 ==> 1. Array.prototype.slice.call(类数组); 2. [].slice.call(类数组)
        // 2 创建了一个新数组 所以相对于 2 而言 1 更好
        // 1 的写法 要求是能看懂 使用的话 还是使用 ES6
    </script>

    <script>
        // 应用2 ==> 实现继承
        // 当前这样的写法是有一定问题的 不符合实际 还没有使用到继承
        function User(firstName, lastName, age) {
            this.firstName = firstName;
            this.lastName = lastName;
            this.age = age;
            this.fullName = this.firstName + " " + this.lastName;
        }

        User.prototype.sayHello = function () {
            console.log(`大家好，我叫${this.fullName}，今年${this.age}岁了`);
        }

        function VIPUser(firstName, lastName, age, money) {
            User.call(this, firstName, lastName, age);
            this.money = money;
        }

        VIPUser.prototype.upgrade = function () {
            console.log(`使用了${100}元软妹币，升级了！`);
            this.money -= 100;
        }

        var vUser = new VIPUser("姬", "成", 1, 100);
    </script>

    <script>
        // 见参考图 - 1
        // 应用2 ==> 实现继承 圣杯模式
        // ES5之前的写法 面试题会常问 一定得会
        // myPlugin.inherit = (function () {
        //     var Temp = function () {}
        //     return function (son, father) {
        //         Temp.prototype = father.prototype;
        //         son.prototype = new Temp();
        //         son.prototype.constructor = son; // 完善constructor的指向
        //         son.prototype.uber = father.prototype; // 圣杯模式的标准写法 为了方便子类获取父类的东西
        //         // son.prototype.uber = father; // 袁老师的写法
        //     }
        // }());

        // 利用ES5中 Object.create() 的写法
        myPlugin.inherit = function (son, father) {
            son.prototype = Object.create(father.prototype)
            son.prototype.constructor = son; // 完善constructor的指向
            son.prototype.uber = father.prototype; // 圣杯模式的标准写法 为了方便子类获取父类的东西
            // son.prototype.uber = father; // 袁老师的写法
        }

        function User(firstName, lastName, age) {
            this.firstName = firstName;
            this.lastName = lastName;
            this.age = age;
            this.fullName = this.firstName + " " + this.lastName;
        }

        User.prototype.sayHello = function () {
            console.log(`大家好，我叫${this.fullName}，今年${this.age}岁了`);
        }

        function VIPUser(firstName, lastName, age, money) {
            // this.uber(firstName, lastName, age); // 袁老师的写法
            User.call(this, firstName, lastName, age);
            this.money = money;
        }

        myPlugin.inherit(VIPUser, User);

        VIPUser.prototype.upgrade = function () {
            console.log(`使用了${100}元软妹币，升级了！`);
            this.money -= 100;
        }

        var vUser = new VIPUser("姬", "成", 1, 100);

        // 如果这一块理解起来有困难 建议回看视频 有图解 和 老师讲解
        // 最后30min左右
    </script>
</body>

</html>
```

- 参考图 - 1

![20210226111455](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210226111455.png)


## 3. [拓展]属性描述符

[属性描述符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty): 它表达了一个属性的相关信息（元数据），**它本质上是一个对象**。

### 数据属性 和 存取器属性(也称访问器属性)

1. 数据属性
2. 存取器属性
   1. 当给它赋值，会自动运行一个函数 `setter`
   2. 当获取它的值时，会自动运行一个函数 `getter`


其他的属性描述符

### 获取属性描述符对象 Object.getOwnPropertyDescriptor

**Object.getOwnPropertyDescriptor**

获取某个对象的某个属性的属性描述符对象（该属性必须直接属于该对象）

==利用属性描述符的知识 完善DOM案例17 运动边界处理的问题==

### test.html

**Simplified version**

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <title>1-18min</title>
</head>

<body>
    <script>
        var obj = {};

        Object.defineProperty(obj, "x", {
            value: 3,
        });

        console.log(obj.x); // 3
    </script>

    <script>
        var obj = {};

        Object.defineProperty(obj, "x", {
            get: function () {
                console.log("读取属性x");
                return 2;
            },
            set: function (val) {
                console.log("给属性赋值为" + val);
            }
        });

        obj.x = 3; // "给属性赋值为3"

        console.log(obj.x);
        // "读取属性x"
        // 2
    </script>
</body>

</html>
```

**Include annotated version**

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <title>1-18min</title>
</head>

<body>
    <script>
        var obj = {};

        // 此时 "x" 依旧是一个数据属性 而非存取器属性
        Object.defineProperty(obj, "x", {
            value: 3,
        });

        // obj.x = 3; // 上面的这种写法实际上就等价于这种写法

        console.log(obj.x); // 3
    </script>

    <script>
        // 存取器属性
        var obj = {};

        Object.defineProperty(obj, "x", {
            // 一旦写了 set方法 或 get方法 后 该属性 "x" 就变成是 一个存取器属性
            // 不能再有 value 属性
            // value: 3, // 如果不把该语句给注释掉 那么会报错

            // 属性描述符
            get: function () {
                //当读取属性x时，运行的函数
                console.log("读取属性x");
                //该函数的返回值，将作为属性的值
                return 2;
            },
            set: function (val) {
                //当给该属性赋值时，运行的函数
                //val：表示要赋的值
                console.log("给属性赋值为" + val);
            }
        });

        obj.x = 3; //相当于运行了 set(3)

        console.log(obj.x);
        /* 面试题: 以上程序运行后的输出结果是?
        1. 首先 由于 obj.x = 3; 这是在设置属性"x"的值 会调用set函数 所以会输出 ==> "给属性赋值为3";
        2. 再 console.log(obj.x); 这一步在读取属性"x"的值 会调用get函数 所以会输出 ==> "读取属性x"
        3. 最后 obj.x 获取到的值 是get函数的返回值 也就是2 所以会输出 ==> 2 */
    </script>
</body>

</html>
```

**Simplified version**

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <title>20-33min</title>
</head>

<body>
    <script>
        function User(name, age) {
            this.name = name;
            if (age < 0) {
                age = 0;
            } else if (age > 100) {
                age = 100;
            }
            this.age = age;
        }

        var u = new User("abc", 10000);
        console.log(u.age); // 100
        u.age = 10000;
        console.log(u.age); // 10000
    </script>

    <script>
        function User(name, age) {
            this.name = name;
            var _age;
            Object.defineProperty(this, "age", {
                get: function () {
                    // console.log("运行了age的get");
                    return _age;
                },
                set: function (val) {
                    // console.log("运行了age的set: " + val);
                    if (val < 0) {
                        val = 0;
                    } else if (val > 100) {
                        val = 100;
                    }
                    _age = val;
                }
            })
            this.age = age;
        }

        var u = new User("abc", 10000);
        console.log(u.age); // 100
        u.age = 10000;
        console.log(u.age); // 100
    </script>

    <script>
        // 面试题
        function User(name, age) {
            this.name = name;
            var _age;
            Object.defineProperty(this, "age", {
                get: function () {
                    console.log("运行了age的get");
                    return _age;
                },
                set: function (val) {
                    console.log("运行了age的set: " + val);
                    if (val < 0) {
                        val = 0;
                    } else if (val > 100) {
                        val = 100;
                    }
                    _age = val;
                }
            })

            this.age = age;
        }

        var u = new User("abc", -1);
        u.age = u.age + 10000;
        console.log(u.age);
        // 输出结果
        // 1. 运行了age的set: -1
        // 2. 运行了age的get
        // 3. 运行了age的set: 1000
        // 4. 运行了age的get
        // 5. 100
    </script>
</body>

</html>
```

**Include annotated version**

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <title>20-33min</title>
</head>

<body>
    <script>
        /* 下面介绍一个场景 数据属性导致的问题 */
        function User(name, age) {
            this.name = name;
            // 当创建一个用户时 需求 ==> 限定年龄的范围 0-100
            // 小于 0 则赋值为 0 ; 大于 100 则赋值为 100
            if (age < 0) {
                age = 0;
            } else if (age > 100) {
                age = 100;
            }
            this.age = age;
        }

        var u = new User("abc", 10000); // 创建一个实例 u 年龄越界
        console.log(u.age); // 100 ==> 调用构造函数来创建实例的时候 还是可以起到预防作用的 但是...
        u.age = 10000; // 如果再重新修改实例u上的age 那么后续的修改将无法预防
        console.log(u.age); // 10000
    </script>

    <script>
        /* 利用访问器属性 可以很好的解决上述这类情况所导致的问题 */
        function User(name, age) {
            this.name = name;
            var _age; // _age 前面的下划线是一种常用记号 表示只能通过对象方法访问的属性 (实际上直接用age 不声明_age 也可以)
            Object.defineProperty(this, "age", {
                get: function () {
                    // console.log("运行了age的get");
                    return _age;
                },
                set: function (val) {
                    // console.log("运行了age的set: " + val);
                    if (val < 0) {
                        val = 0;
                    } else if (val > 100) {
                        val = 100;
                    }
                    _age = val;
                }
            })

            this.age = age;
        }

        var u = new User("abc", 10000);
        console.log(u.age); // 100
        u.age = 10000;
        console.log(u.age); // 100
    </script>

    <script>
        /* 面试题 控制台的输出结果是? */
        function User(name, age) {
            this.name = name;
            var _age;
            Object.defineProperty(this, "age", {
                get: function () {
                    console.log("运行了age的get");
                    return _age;
                },
                set: function (val) {
                    console.log("运行了age的set: " + val);
                    if (val < 0) {
                        val = 0;
                    } else if (val > 100) {
                        val = 100;
                    }
                    _age = val;
                }
            })

            this.age = age;
        }

        var u = new User("abc", -1); // 调用了构造函数 User 创建实例u 传入了 age值 -1 所以会输出 ==> 运行了age的set: -1
        u.age = u.age + 10000; // 先执行赋值符号右边的 u.age + 10000 ==> 读取 age 的值 ==> 调用get 所以会输出 ==> 运行了age的get
        // 再将赋值符号右边得到的结果 10000 赋值给 u.age ==> 设置 age 的值 ==> 调用set 所以会输出 ==> 运行了age的set: 1000
        console.log(u.age); // 先是读取 age 的值 ==> 调用get 所以会输出 ==> 运行了age的get
        // 再将读取到的结果 100 利用 console.log(100); 输出 ==> 100
        // 输出结果
        // 1. 运行了age的set: -1
        // 2. 运行了age的get
        // 3. 运行了age的set: 1000
        // 4. 运行了age的get
        // 5. 100
    </script>
</body>

</html>
```


**Simplified version**

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <title>自由移动</title>
    <style>
        div {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 100px;
            height: 100px;
            border: 1px solid red;
            border-radius: 50%;
        }
    </style>
</head>

<body>
    <div></div>
    <script>
        const moveDiv = document.querySelector("div");
        let config = {
            width: 100,
            height: 100,
            _x: 0,
            _y: 0,
            disX: 2,
            disY: 2,
            duration: 16
        }

        Object.defineProperty(config, "x", {
            get: function () {
                return this._x;
            },
            set: function (val) {
                if (val < 0) {
                    val = 0;
                    this.disX *= -1;
                } else if (val > document.documentElement.clientWidth - this.width) {
                    val = document.documentElement.clientWidth - this.width;
                    this.disX *= -1;
                }
                this._x = val;
                moveDiv.style.left = val + "px";
            }
        })
        Object.defineProperty(config, "y", {
            get: function () {
                return this._y;
            },
            set: function (val) {
                if (val < 0) {
                    val = 0;
                    this.disY *= -1;
                } else if (val > document.documentElement.clientHeight - this.height) {
                    val = document.documentElement.clientHeight - this.height;
                    this.disY *= -1;
                }
                this._y = val;
                moveDiv.style.top = val + "px";
            }
        })
        setInterval(() => {
            config.x += config.disX;
            config.y += config.disY;
        }, config.duration);
    </script>
</body>

</html>
```

**Include annotated version**

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>33min-48min</title>
    <style>
        .move {
            position: fixed;
            left: 0;
            top: 0;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: red;
        }
    </style>
</head>

<body>
    <div class="move">
        <!-- 该div自动向右下移动，遇到边界反弹 -->
    </div>
    <script>
        /* 存取器属性的应用2 */
        /* 袁老师DOM案例 17.自由移动plus */
        // (这一部分很Nice 下面改写后的移动案例 很棒 比之前写的好了很多)
        // 和前面的很多知识点结合起来讲解了 ==> 比如说 div.innerText = "abc" ==> 然后页面上就会显示 abc 之所以会这样
        // 实际上是因为 innerText 就是一个存取器属性 ==> 当我们在给这个属性进行赋值的时候
        // 就会调用 setter 函数 进行一系列的操作 最后在这个元素身上添加上了文本 abc
        // 而不像是一个数据属性 仅仅是把结果 "abc" 赋值给了 属性 innerText
        var div = document.querySelector(".move");
        var config = {
            _x: 0, // _x 前面的下划线是一种常用的记号, 用于表示只能通过对象方法访问的属性
            // 而访问器属性 x 则包含一个 getter 函数 和一个 setter 函数
            // getter 函数 用于返回 _x 的值
            // setter 函数 通过计算来确定最终 _x 的值
            _y: 0,
            xDis: 2,
            yDis: 2,
            duration: 16,
            width: 100,
            height: 100
        }

        Object.defineProperty(config, "x", {
            get: function () {
                return this._x;
            },
            set: function (val) {
                if (val < 0) {
                    val = 0;
                } else if (val > document.documentElement.clientWidth - this.width) {
                    val = document.documentElement.clientWidth - this.width;
                }
                this._x = val;
                div.style.left = val + "px";
            }
        })

        Object.defineProperty(config, "y", {
            get: function () {
                return this._y;
            },
            set: function (val) {
                if (val < 0) {
                    val = 0;
                } else if (val > document.documentElement.clientHeight - this.height) {
                    val = document.documentElement.clientHeight - this.height;
                }
                this._y = val;
                div.style.top = val + "px";
            }
        })

        // 此时只需要关注数值的变化即可 不用再去考虑数值改变后再改变dom元素的属性呀...啥的 就优化了很多
        setInterval(function () {
            config.x += config.xDis;
            config.y += config.yDis;
            // 边界判定
            if (config.y === document.documentElement.clientHeight - config.height ||
                config.y === 0) {
                config.yDis = -config.yDis;
            }
            if (config.x === document.documentElement.clientWidth - config.width ||
                config.x === 0) {
                config.xDis = -config.xDis;
            }
        }, config.duration);
    </script>
</body>

</html>
```

**Simplified version**

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <title>48-63</title>
</head>

<body>
    <script>
        var obj = {
            x: 1,
            y: 2
        };

        /* 面试题 ==> obj的name属性值固定为abc，而且不能被重新赋值 */

        /* 写法1 */
        Object.defineProperty(obj, "name", {
            get: function() {
                return "abc";
            }
        })

        /* 写法2 */
        Object.defineProperty(obj, "name", {
            value: "abc",
            writable: false
        })
    </script>

    <script>
        var obj = {
            x: 1,
            y: 2
        };

        Object.defineProperty(obj, "name", {
            value: "abc",
            writable: false,
            enumerable: false,
            configurable: true
        })

        for (var prop in obj) {
            console.log(prop);
        }
        // "x"
        // "y"
    </script>

    <script>
        var obj = {
            x: 1,
            y: 2
        };

        Object.defineProperty(obj, "name", {
            value: "abc",
            writable: false,
            enumerable: false,
            configurable: true
        })

        console.log(Object.getOwnPropertyDescriptor(obj, "name"));
        // {value: "abc", writable: false, enumerable: false, configurable: true}
    </script>

    <script>
        console.log(Object.getOwnPropertyDescriptor(document.body.__proto__.__proto__, "innerText"));
        // {enumerable: true, configurable: true, get: ƒ, set: ƒ}
    </script>
</body>

</html>
```

**Include annotated version**

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>48-63</title>
</head>

<body>
    <script>
        var obj = {
            x: 1,
            y: 2
        };

        /* 面试题 ==> obj的name属性值固定为abc，而且不能被重新赋值 */

        /* 写法1 */
        // Object.defineProperty(obj, "name", {
        //     get: function() {
        //         return "abc";
        //     }
        // })

        /* 写法2 */
        Object.defineProperty(obj, "name", {
            value: "abc",
            writable: false
        })
    </script>

    <script>
        var obj = {
            x: 1,
            y: 2
        };

        Object.defineProperty(obj, "name", {
            value: "abc",
            writable: false,
            enumerable: false, //不可迭代 遍历
            // enumerable 接触到的应用场景 ==> 原型链上 我们在遍历一个实例对象时 往往不会遍历出 Object.prototype 上的属性 就是因为配置了 enumerable: false; 表示这些属性是不可遍历的
            configurable: true // 表示该属性是否是可配置的属性
        })

        /* 补充: value writable 和 get set 这俩组之间不能共用
        存在第一组 value writable 表示当前的属性是一个数据属性
        存在第二组 get set 表示当前的属性是一个存取器属性 */

        for (var prop in obj) {
            console.log(prop); // 不会遍历 name 属性
        }
        // 只会输出 x y
    </script>

    <script>
        // 获取属性描述符对象 ==> Object.getOwnPropertyDescriptor
        var obj = {
            x: 1,
            y: 2
        };

        Object.defineProperty(obj, "name", {
            value: "abc",
            writable: false,
            enumerable: false,
            configurable: true
        })

        console.log(Object.getOwnPropertyDescriptor(obj, "name"));
        // {value: "abc", writable: false, enumerable: false, configurable: true}
    </script>

    <script>
        console.log(Object.getOwnPropertyDescriptor(document.body.__proto__.__proto__, "innerText"));
        // {enumerable: true, configurable: true, get: ƒ, set: ƒ}
    </script>
</body>

</html>
```

## ==4. 执行上下文==

函数执行上下文：一个函数运行之前，创建的一块内存空间，空间中包含有该函数执行所需要的数据，为该函数执行提供支持。

执行上下文栈：call stack，所有执行上下文组成的内存空间。

栈：一种数据结构，先进后出，后进先出。

全局执行上下文：所有JS代码执行之前，都必须有该环境。

JS引擎始终执行的是**栈顶**的上下文。

### 执行上下文中的内容

1. this指向

- 直接调用函数，this指向全局对象

- 在函数外，this指向全局对象

- 通过对象调用或new一个函数，this指向调用的对象或新对象

> this的指向是在调用函数的时候才确定的;

2. VO 变量对象

Variable Object：VO 中记录了该环境中所有声明的参数、变量和函数

Global Object: GO，全局执行上下文中的VO

Active Object：AO，当前正在执行的上下文中的VO


- 确定所有形参值以及特殊变量arguments
- 确定函数中通过var声明的变量，将它们的值设置为undefined，如果VO中已有该名称，则直接忽略。
- 确定函数中通过字面量声明的函数，将它们的值设置为指向函数对象，如果VO中已存在该名称，则覆盖。
> 当一个上下文中的代码执行的时候，如果上下文中不存在某个属性，则会从之前的上下文寻找。


### test.html

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <title>执行上下文</title>
</head>

<body>
    <script>
        function A(a, b) {
            console.log(a, b);
            var b = 123;
            console.log(a, b);

            function b() {
                var d = 123;
            } // fun b
        }

        A(1, 2);
    </script>

    <script>
        var a = 2;

        function A(a, b) {
            console.log(a, b);
            var b = 123;


            function b() {} // fun1

            var a = function () {} // fun2

            console.log(a, b);
        }
        A(1, 2);
    </script>

    <script>
        /* 面试题1 */
        var foo = 1;

        function bar() {
            console.log(foo);
            if (!foo) {
                var foo = 10;
            }
            console.log(foo);
        }

        bar();
    </script>

    <script>
        /* 面试题2 */
        var a = 1;

        function b() {
            console.log(a);
            a = 10;
            return;

            function a() {} // fun1
        }
        b();
        console.log(a);
    </script>

    <script>
        /* 面试题3 */
        console.log(foo);
        var foo = "A";
        console.log(foo);
        var foo = function () {
            console.log("B");
        } // fun B
        console.log(foo);
        foo();

        function foo() {
            console.log("C");
        } // fun C
        console.log(foo)
        foo();
    </script>

    <script>
        /* 面试题4 */
        var foo = 1;

        function bar(a) {
            var a1 = a;
            var a = foo;

            function a() {
                console.log(a);
            } // fun a
            a1();
        }

        bar(3);
    </script>
</body>

</html>
```

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <title>执行上下文</title>
</head>

<body>
    <script>
        function A(a, b) {
            console.log(a, b); // 1 fun b
            var b = 123;
            console.log(a, b); // 1 123

            function b() {
                var d = 123;
            }
        }

        A(1, 2);
    </script>

    <script>
        var a = 2;

        function A(a, b) {
            console.log(a, b); // 1 fun1
            var b = 123;


            function b() {} // fun1

            var a = function () {} // fun2

            console.log(a, b); // fun2 123
        }
        A(1, 2);
    </script>

    <script>
        /* 面试题1 */
        var foo = 1;

        function bar() {
            console.log(foo); //undefined
            if (!foo) {
                var foo = 10;
            }
            console.log(foo); //10
        }

        bar();
    </script>

    <script>
        /* 面试题2 */
        var a = 1;

        function b() {
            console.log(a); // fun1
            a = 10;
            return;

            function a() {} // fun1
        }
        b();
        console.log(a); // 1
    </script>

    <script>
        /* 面试题3 */
        console.log(foo); // fun console.log("C")
        var foo = "A";
        console.log(foo) // A
        var foo = function () {
            console.log("B");
        }
        console.log(foo); // fun console.log("B")
        foo(); // B
        function foo() {
            console.log("C");
        }
        console.log(foo) // fun console.log("B")
        foo(); // B
    </script>

    <script>
        /* 面试题4 */
        var foo = 1;

        function bar(a) {
            var a1 = a;
            var a = foo;

            function a() {
                console.log(a); // 1
            }
            a1();
        }

        bar(3);
    </script>
</body>

</html>
```

## 5. 作用域链

1. VO中包含一个额外的属性，该属性指向创建该VO的函数本身
2. 每个函数在创建时，会有一个隐藏属性```[[scope]]```，它指向创建该函数时的AO
3. 当访问一个变量时，会先查找自身VO中是否存在，如果不存在，则依次查找```[[scope]]```属性。

某些浏览器会优化作用域链，函数的```[[scope]]```中仅保留需要用到的数据。

### test.html

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <title>作用域链Test</title>
</head>

<body>
    <script>
        var g = 0;

        function A() {
            var a = 1;

            function B() {
                var b = 2;
                var C = function () {
                    var c = 3;
                    console.log(c, b, a, g);
                }
                C();
            }

            B();
        }

        A();
    </script>

    <script>
        var count = 100;

        function A() {
            var count = 0;
            return function () {
                count++;
                console.log(count);
            }
        }

        var test = A();

        test();
        test();
        test();

        console.log(count);
    </script>

    <script>
        var a = 1;

        function A() {
            console.log(a);
        }

        function Special() {
            var a = 5;
            var B = A;
            B();
        }

        Special();
    </script>

    <script>
        /* 面试题1 */
        var foo = {
            n: 1
        };
        (function (foo) {
            console.log(foo.n);
            foo.n = 3;
            var foo = {
                n: 2
            };
            console.log(foo.n);
        })(foo);
        console.log(foo.n);
    </script>

    <script>
        /* 面试题2 */
        var food = "rice";
        var eat = function () {
            console.log(`eat ${food}`);
        };
        (function () {
            var food = "noodle";
            eat();
        })();
    </script>

    <script>
        /* 面试题3 */
        var food = "rice";
        (function () {
            var food = "noodle";
            var eat = function () {
                console.log(`eat ${food}`);
            };
            eat();
        })();
    </script>

    <script>
        /* 面试题4 */
        console.time()
        for (var i = 0; i < 3; i++) {
            setTimeout(function () {
                console.log(i);
            }, 1000)
        }
        console.timeEnd()




        console.time();
        for (var i = 0; i < 3; i++) {
            (function (i) {
                setTimeout(function () {
                    console.log(i);
                }, 1000)
            }(i));
        }
        console.timeEnd();
    </script>
</body>

</html>
```

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>作用域链</title>
</head>

<body>
    <script>
        var g = 0;

        function A() {
            var a = 1;

            function B() {
                var b = 2;
                var C = function () {
                    var c = 3;
                    console.log(c, b, a, g); // 3 2 1 0
                }
                C();
            }

            B();
        }

        A();
    </script>

    <script>
        var count = 100;

        function A() {
            var count = 0;
            return function () {
                count++;
                console.log(count);
            }
        }

        var test = A();

        test(); // 1
        test(); // 2
        test(); // 3

        console.log(count); // 100
    </script>

    <script>
        var a = 1;

        function A() {
            console.log(a);
        }

        function Special() {
            var a = 5;
            var B = A;
            B();
        }

        Special(); // 1
    </script>

    <script>
        /* 面试题1 */
        var foo = {
            n: 1
        };
        (function (foo) {
            console.log(foo.n); // 1
            foo.n = 3;
            var foo = {
                n: 2
            };
            console.log(foo.n); // 2
        })(foo);
        console.log(foo.n); // 3
    </script>

    <script>
        /* 面试题2 */
        var food = "rice";
        var eat = function () {
            console.log(`eat ${food}`);
        };
        (function () {
            var food = "noodle";
            eat(); //eat rice
        })();
    </script>

    <script>
        /* 面试题3 */
        var food = "rice";
        (function () {
            var food = "noodle";
            var eat = function () {
                console.log(`eat ${food}`);
            };
            eat(); //eat noodle
        })();
    </script>

    <script>
        /* 面试题4 */
        console.time()
        for (var i = 0; i < 3; i++) {
            setTimeout(function () { // 这里的fun是作为参数传入的
                // 也就是说 该匿名函数是在全局位置创建的
                console.log(i); // 一秒后 打印出3个3
            }, 1000)
        }
        console.timeEnd()




        console.time();
        for (var i = 0; i < 3; i++) {
            (function (i) {
                setTimeout(function () {
                    // 该匿名函数是在对应的立即执行函数位置创建的
                    console.log(i); // 一秒后 依次打印出 0 1 2
                }, 1000)
            }(i));
        }
        console.timeEnd();
    </script>
</body>

</html>
```

## 6. 事件循环

异步：某些函数不会立即执行，需要等到某个时机成熟后才会执行，该函数叫做异步函数。

浏览器的线程：

1. JS执行引擎：负责执行JS代码
2. 渲染线程：负责渲染页面
3. 计时器线程：负责计时
4. 事件监听线程：负责监听事件
5. http网络线程：负责网络通信

事件队列：一块内存空间，用于存放执行时机到达的异步函数。当JS引擎空闲（执行栈没有可执行的上下文），它会从事件队列中拿出第一个函数执行。

事件循环：event loop，是指函数在执行栈、宿主线程、事件队列中的循环移动。

[事件队列](https://www.cnblogs.com/nayek/p/11729923.html)

[Event loop](https://zhuanlan.zhihu.com/p/41543963)

### test.html

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <title>事件循环</title>
</head>

<body>
    <script>
        setTimeout(function A() {
            console.log("异步代码")
        }, 0)

        for (var i = 0; i < 10000; i++) {
            console.log(i);
        }
    </script>

    <button>点击</button>
    <script>
        document.querySelector("button").onclick = function A() {
            setTimeout(function B() {
                console.log("异步代码")
            }, 0);
            loop();
        }

        function loop() {
            for (var i = 0; i < 10000; i++) {
                console.log(i);
            }
        }

        loop();
    </script>
</body>

</html>
```

## 7. 骚操作-对象混合和克隆

[Object.assign](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)

Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。

**Syntax**

Object.assign(target, ...sources)

### test.html

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <title>对象混合</title>
</head>

<body>
    <script>
        if (!(window.myPlugin)) {
            window.myPlugin = {};
        }
        /**
         * obj2混合到obj1产生新的对象
         */
        window.myPlugin.mixin = function (target, source) { // source 覆盖 target
            var newObj = {};
            for (var prop in source) {
                newObj[prop] = source[prop];
            }
            for (var prop in target) {
                if (!(prop in source)) {
                    newObj[prop] = target[prop];
                }
            }
            return newObj;
        }

        // window.myPlugin.mixin = function (source1, source2) {
        //     return Object.assign({}, source1, source2);
        // }

        // 两个对象，混合后产生一个新对象

        var obj1 = {
            x: 1,
            y: 3,
            z: 5
        };

        var obj2 = {
            x: "abc",
            z: "bcd",
            h: "aaa"
        };

        // var obj = Object.assign(obj1, obj2);
        // 上面这种写法会出问题 就是直接将obj2中的内容混合到obj1中, obj1会被改变
        // obj === obj1 结果是 true
        var obj = Object.assign({}, obj1, obj2);
        console.log(obj);

        var obj = myPlugin.mixin(obj1, obj2);
        console.log(obj);
    </script>

    <script>
        /* 对象混合的实际应用 ==> 案例 图片瀑布流 */
        window.myPlugin.createWaterFall = function (option) {
            var defaulOption = {
                minGap: 10, //最小间隙
                imgSrcs: [], //图片路径的数组
                imgWidth: 220, //单张图片的宽度
                container: document.body //容器
            };
            var option = Object.assign({}, defaulOption, option);
            // ...
        }
    </script>

    <script>
        /* 对象混合的常见应用场景
        在调用某个方法时 用户只需要传入他想要改变的参数值即可
        其余用户没有传入的 都使用默认值 这样调用方法就会变得很方便 */
        complicate({
            a: 123,
            b: 34
        });

        // option参数是一个对象，表示配置对象
        function complicate(option) {
            //如果没有传递，则使用默认值
            var defaultOption = {
                a: "default-a",
                b: "default-b",
                c: "default-c",
                d: "default-d",
                e: "default-e"
            };
            var opt = myPlugin.mixin(defaultOption, option);
            console.log(opt);
        }
    </script>
</body>

</html>
```

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <title>对象克隆</title>
</head>

<body>

    <script>
        if (!(this.myPlugin)) {
            this.myPlugin = {};
        }
        this.myPlugin.clone = function (obj, deep) {
            if (Array.isArray(obj)) {
                if (deep) {
                    var newArr = [];
                    for (var i = 0; i < obj.length; i++) {
                        newArr.push(this.clone(obj[i]));
                    }
                    return newArr;
                } else {
                    return obj.slice();
                }
            } else if (typeof obj === "object") {
                var newObj = {};
                if (deep) {
                    for (var prop in obj) {
                        newObj[prop] = this.clone(obj[prop], deep)
                    }
                } else {
                    for (var prop in obj) {
                        newObj[prop] = obj[prop];
                    }
                }
                return newObj;
            } else {
                return obj;
            }
        }

        var obj = [123, [45, 4, 5], {
            x: [234, 454]
        }];

        var newObj = myPlugin.clone(obj, true);
        console.log("obj ==> ", obj);
        console.log("newObj ==> ", newObj);
    </script>
</body>

</html>
```

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <title>对象克隆</title>
</head>

<body>

    <script>
        if (!(this.myPlugin)) {
            this.myPlugin = {};
        }
        /**
         * 克隆一个对象
         * @param {boolean} deep 是否深度克隆
         */
        this.myPlugin.clone = function (obj, deep) {
            /* 分析
            最外层判断 ==> 先判断是 数组 还是 对象 还是 基本数据类型
                a. 如果是基本数据类型 则直接返回
                b. 若是数组 则进一步判断是否是深度克隆
                    若是 则先创建一个空数组 并调用push方法 递归数组的每一项
                    若不是 则直接利用 slice方法 将数组复制 然后返回即可
                c. 若是对象 则新建一个空对象 并判断是否是深度克隆
                    若是 则遍历obj中的每一项 并递归 来给newObj赋值
                    若不是 则直接递归obj中的每一项 并将值赋给newObj */
            if (Array.isArray(obj)) {
                if (deep) {
                    // 深度克隆
                    var newArr = [];
                    for (var i = 0; i < obj.length; i++) {
                        newArr.push(this.clone(obj[i], deep));
                    }
                    return newArr;
                } else {
                    return obj.slice(); // 复制数组
                }
            } else if (typeof obj === "object") {
                var newObj = {};
                if (deep) {
                    for (var prop in obj) {
                        newObj[prop] = this.clone(obj[prop], deep);
                    }
                } else {
                    for (var prop in obj) {
                        newObj[prop] = obj[prop];
                    }
                }
                return newObj;
            } else {
                // 函数、原始类型
                return obj; // 递归的终止条件
            }
        }

        // 克隆obj
        // 浅度克隆，深度克隆
        var obj = [123, [45, 4, 5], {
            x: [234, 454]
        }];

        var newObj = myPlugin.clone(obj, true);
        console.log(newObj);

    </script>
</body>

</html>
```

## 8. 骚操作-函数防抖和函数节流

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>函数防抖 动作结束后执行</title>
</head>

<body>
    <script>
        // 高阶函数：在函数内部返回一个新的函数
        // 函数防抖: debounce
        /**
         * 函数防抖
         * 封装这部分的功能时 需要注意3个点
         * 1. timer 变量不能污染全局
         * 2. 接受回调函数传入的参数问题
         * 3. 回调函数中的this指向问题
         */
        this.myPlugin.debounce = function (callback, time) {
            var timer; // 将timer写在函数内部 防止污染全局
            return function () {
                clearTimeout(timer); // 清除之前的计时
                var args = arguments; // 利用闭包保存参数数组
                // 使用 arguments 是考虑到参数可能不止一个
                timer = setTimeout(function () {
                    callback.apply(null, args);
                    // this 的指向问题 在外面处理
                    // 即:调用debounce传入回调函数的时候 加上一个 bind方法 绑定 this 的指向
                }, time);
            }
        }

        var handle = myPlugin.debounce(function (width) {
            console.log(width);
        }, 1000);
        window.onresize = function () {
            handle(document.documentElement.clientWidth);
        }
    </script>

    <input type="text">
    <script>
        if (!(this.myPlugin)) {
            this.myPlugin = {};
        }
        this.myPlugin.debounce = function (callback, time) {
            var timer;
            return function () {
                clearTimeout(timer);
                var args = arguments;
                timer = setTimeout(() => {
                    callback.apply(null, args);
                }, time);
            }
        }
        var inp = document.querySelector("input");
        var handle = this.myPlugin.debounce(function (val, inp) {
            console.log("val ==> ", val);
            console.log("inp ==> ", inp);
        }, 1000)
        inp.oninput = function () {
            handle(this.value, this);
        }
    </script>
</body>

</html>

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>问题</title>
</head>

<body>
    <script>
        var obj = {
            x: 10
        }
        if (!(this.myPlugin)) {
            this.myPlugin = {};
        }
        this.myPlugin.debounce = function (callback, time) {
            var timer;
            return function () {
                clearTimeout(timer);
                var agrs = arguments;
                timer = setTimeout(() => {
                    callback.apply(null, agrs);
                    // callback.apply(obj, agrs);
                }, time);
            }
        }

        var func = function (width) {
            console.log(width);
            console.log(this);
        }.bind(window);
        var handle = myPlugin.debounce(func, 1000);
        window.onresize = function () {
            handle(document.documentElement.clientWidth);
        }

        // 问题: this指向不理解
        // 为什么 func 绑定的this指向 ==> func.bind(window) ==> this指向window
        // 不能使用 callback.apply(obj, args); 来改变 this 的指向 ==> 为啥 this还是指向 window 不是指向 obj
    </script>
</body>

</html>
```

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <title>mdn bind</title>
</head>

<body>
    <script>
        var x = 10;
        const module = {
            x: 42,
            getX: function () {
                return this.x;
            }
        };

        console.log(module.getX()); // 42

        const unboundGetX = module.getX;
        console.log(unboundGetX()); // 10 全局环境下调用 this 指向 window

        const boundGetX = unboundGetX.bind(module);
        console.log(boundGetX()); // 42


        console.log(boundGetX.apply(window)); // 42
        console.log(boundGetX.call(window)); // 42
        console.log(unboundGetX.apply(window)); // 10
        /* 小结:
        感觉上 bind 绑定了 this 的指向之后 那么就不能在使用 apply 或 call 再来改变this指向了...
        如果是这样的话 那么上述的问题就能理解了 */
    </script>
</body>

</html>
```

**bind mdn 想通过mdn上的相关文档 来解决遇到问题 发现里面涉及到的内容有些多 感觉知识量蛮大的 现在看不合适**

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <title>函数节流 每间隔一段时间执行</title>
</head>

<body>
    <script>
        if (!(this.myPlugin)) {
            this.myPlugin = {};
        }
        /**
         * 函数节流
         */
        this.myPlugin.throttle = function (callback, time, immediately) {
            if (immediately === undefined) {
                immediately = true;
            }
            if (immediately) {
                var t;
                return function () {
                    if (immediately) {
                        if (!t || Date.now() - t >= time) { //之前没有计时 或 距离上次执行的时间已超过规定的值
                            callback.apply(null, arguments);
                            t = Date.now(); //得到的当前时间戳
                        }
                    }
                }
            } else {
                var timer;
                return function () {
                    if (timer) {
                        return;
                    }
                    var args = arguments; // 利用闭包保存参数数组
                    timer = setTimeout(function () {
                        callback.apply(null, args);
                        timer = null;
                    }, time);
                }
            }
        }

        var handle = myPlugin.throttle(test, 1000, true);

        // 保证一个时间段内执行一次
        window.onresize = function () {
            handle();
        }

        function test() {
            console.log("a");
        }

        // handle();
        // handle();
        // handle();
        // handle();
        // handle();
        // handle();
        // handle();
        // handle();
        // handle();
        /* 分析
        传入的 immediately 的值的异同
        1. true ==> 表示 立即触发 一开始就会触发一次 这种触发方式是利用时间戳的方式来实现的;
        2. false ==> 表示 非立即触发 一开始并不会触发 第一次触发是指定的一个时间间隔 time 之后;

        结束的异同:
            假设 传入的 time 是 1000 也就是 1000ms 即 1s
            handle函数被调用的时间段是 0-2.5s (持续调用)
        1. 立即触发方式 ==> 一共会触发 3次 ==> 第一次 0s时刻 第二次 1s时刻 第三次 2s时刻
        2. 非立即触发方式 ==> 一共会触发 2次 ==> 第一次 1s时刻 第二次 2s时刻 第三次 3s时刻 */
    </script>
</body>

</html>
```

## 9. [扩展]骚操作-科里化

科里化函数：固定某个函数的一些参数，得到该函数剩余参数的一个新函数，如果没有剩余参数，则调用

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <title>科里化</title>
</head>

<body>
    <!-- <script src="../../plugin/helpers.js"></script> -->
    <script>
        // curry：  Haskell curry
        // 科里化函数：固定某个函数的一些参数，得到该函数剩余参数的一个新函数，如果没有剩余参数，则调用
        if (!(this.myPlugin)) {
            this.myPlugin = {};
        }

        // this.myPlugin.curry = function (func) {
        //     var args = Array.from(arguments).slice(1);
        //     var that = this;
        //     return function () {
        //         var totalArgs = args.concat(Array.from(arguments));
        //         if (totalArgs.length >= func.length) {
        //             return func.apply(null, totalArgs);
        //         } else {
        //             totalArgs.unshift(func);
        //             return that.curry.apply(that, totalArgs);
        //         }
        //     }
        // }
        this.myPlugin.curry = function(fun){
            var args = Array.from(arguments).slice(1);
            var that = this;
            return function(){
                var totalArgs = args.concat(Array.from(arguments));
                if(totalArgs.length >= fun.length){
                    return fun.apply(null, totalArgs);
                }else{
                    totalArgs.unshift(fun);
                    return that.curry.apply(null, totalArgs);
                }
            }
        }

        function f(x, y, z) {
            return (x + y) * z;
        }

        // 求：(2+3)*5  (2+5)*6  (2+4)*7  (2+4)*16
        var g = myPlugin.curry(f, 2)
        console.log(g(3, 5));
        console.log(g(5, 6));

        var y = g(4);
        // var y = myPlugin.curry(f, 2, 4)

        console.log(y(7));
        console.log(y(16));
    </script>
</body>

</html>
```



```html
<!DOCTYPE html>
<html lang="en">

<head>
    <title>科里化应用举例</title>
    <style>
        .container {
            border: 2px solid;
            padding: 30px;
        }
    </style>
</head>

<body>
    <div class="container"></div>
    <script>
        /**
         * 科里化函数
         * 在函数式编程中，科里化最重要的作用是把多参函数变为单参函数
         */
         this.myPlugin.curry = function (func) {
            var args = Array.prototype.slice.call(arguments, 1);
            var that = this;
            return function () {
                var curArgs = Array.from(arguments);
                var totalArgs = args.concat(curArgs);
                if (totalArgs.length >= func.length) {
                    return func.apply(null, totalArgs);
                } else {
                    totalArgs.unshift(func);
                    return that.curry.apply(that, totalArgs);
                }
            }
        }
        function createElement(container, name, props, styles, content) {
            var ele = document.createElement(name);
            container.appendChild(ele);

            for (var prop in props) {
                ele[prop] = props[prop];
            }

            for (var prop in styles) {
                ele.style[prop] = styles[prop];
            }
            if (content) {
                ele.innerHTML = content;
            }
        }
        var div = document.querySelector(".container");
        var create = myPlugin.curry(createElement, div, "div", {}, {
            height: "100px",
            background: "#008c8c",
            margin: "30px",
            color:"#fff"
        });

        create("asdfasdf");
        create("2344");
        create("asdfa4545sdf");
        create("asdfa234324234sdf");

        create("asdfa132112313sdf");
        create("563456435634");
        create("啊打发法是发啊手动阀啊");
    </script>
</body>

</html>
```


## 10. [扩展]骚操作-函数管道

![函数管道](https://note.youdao.com/yws/res/31394/49EEFC4F593A41CBA6B6355E630629BF)

函数管道：将多个单参函数组合起来，形成一个新的函数，这些函数中，前一个函数的输出，是后一个函数的输入

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <title>函数管道</title>
</head>

<body>
    <script>
        // 不一定是浏览器环境
        if (!this.myPlugin) {
            this.myPlugin = {};
        }
        /**
         * 科里化函数
         * 在函数式编程中，科里化最重要的作用是把多参函数变为单参函数
         */
        this.myPlugin.curry = function (func) {
            //得到从下标1开始的参数
            var args = Array.prototype.slice.call(arguments, 1);
            var that = this;
            return function () {
                var curArgs = Array.from(arguments); //当前调用的参数
                var totalArgs = args.concat(curArgs); // 注意顺序 args 拼接 curArgs
                if (totalArgs.length >= func.length) {
                    //参数数量够了
                    return func.apply(null, totalArgs);
                } else {
                    //参数数量仍然不够
                    totalArgs.unshift(func);
                    return that.curry.apply(that, totalArgs);
                }
            }
        }
        // 函数管道：将多个单参函数组合起来，形成一个新的函数，这些函数中，前一个函数的输出，是后一个函数的输入

        /**
         * 函数管道
         */
        this.myPlugin.pipe = function () {
            var args = Array.from(arguments);
            return function (val) {
                return args.reduce(function (result, func) {
                    return func(result);
                }, val);
                // for (var i = 0; i < args.length; i++) {
                //     var func = args[i];
                //     val = func(val);
                // }
                // return val;
            }
        }

        //将字符串中每一个单词首字母大写
        function everyFirstLetterUp(str) {
            return str.replace(/\b(\w)(\w*)\b/g, function ($, $1, $2) {
                return $1.toUpperCase() + $2;
            });
        }

        //将字符串中除首字母外的其他字母小写
        function otherLetterLower(str) {
            return str.replace(/\b(\w)(\w*)\b/g, function ($, $1, $2) {
                return $1 + $2.toLowerCase();
            });
        }

        //去掉字符串中所有的空白字符
        function removeEmpty(str) {
            return str.replace(/\s+/g, "");
        }

        //将字符串中第一个单词字符小写
        function firstLetterLower(str) {
            return str.replace(/\w/, function ($) {
                return $.toLowerCase();
            });
        }

        //截取字符串
        function curString(number, str) {
            return str.substr(0, number);
        }

        /* // 特点: 这些函数调用都只传入一个参数
        // 并且前一个函数的返回值就是后一个函数的参数
        var str = "    MY     fIrST    naME";
        str = everyFirstLetterUp(str);
        str = firstLetterLower(str);
        str = otherLetterLower(str);
        str = removeEmpty(str);
        console.log(str); // myFirstName */

        //将一个字符串变为小驼峰命名法

        var smallCamel = myPlugin.pipe(everyFirstLetterUp, firstLetterLower,
            otherLetterLower, removeEmpty, myPlugin.curry(curString, 10));

        console.log(smallCamel("    MY     fIrST    naME"));
        console.log(smallCamel("  asdfasf  sdfasf   ggggggg  hGDGF"));
    </script>
</body>

</html>
```

