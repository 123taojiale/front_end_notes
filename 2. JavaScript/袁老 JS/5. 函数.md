# 五、函数

```
重点:
    5. [作业讲解]函数表达式和this
       掌握回调函数的使用
    8. 递归
       掌握递归的思想
```

## 1. 函数语法

```
重复代码：让程序难以维护
函数主要用于减少重复代码
```

**创建（定义、声明）函数**

```js
function 函数名(){
    // 函数体
}
```

```
函数体的代码不会直接运行，必须要手动调用函数，才能运行其中的代码。
```

**调用函数**

```js
函数名(); // 运行函数体
```

**函数提升**

```
通过字面量声明的函数，会提升到 脚本块 的顶部。
通过字面量声明的函数，会成为全局对象的属性。
```

**其他特点**

```
通过typeof 函数名，得到的结果是"function"
函数内部声明的变量：
    1. 如果不使用var声明，和全局变量一致，表示给全局对象添加属性
    2. 如果使用var声明，变量提升到所在函数的顶部，函数外部不可以使用该变量
注意: 函数中声明的变量，仅能在函数中使用，在外部无效
    函数内部可以访问全局作用域中的变量 但是全局不能访问函数局部作用域中的变量 [进阶课程 ==> 作用域] (现阶段不做详细说明)
```

**参数**

```
参数表示函数运行的未知条件，需要调用者告知的数据
```

```js
// 参数的有效返回在函数体中
function 函数名(形参1, 形参2, ...){ // 函数声明时 确认好形参

}

函数名(实参); // 函数调用时传入实参
// 如果实参没有传递，则对应的形参为undefined
```

**返回值**

```
函数运行后，得到的结果，调用函数时，调用表达式的值就是函数的返回值
return 会直接结束整个函数的运行
return 后面如果不跟任何数据，返回undefined
如果函数中没有书写return，则该函数会在末尾自动return undefined。
```

**文档注释**

```
操作: 在 .js 文件下输入 /** 后 按 回车 就会自动生成文档注释
```

```js
/**
 *
 *
*/
```

**作业**

```
通用函数编写, 新建一个js文件，编写以下函数

1. 写一个函数，该函数用于判断某个数是不是奇数
    函数名参考：isOdd

2. 写一个函数，该函数用于判断某个数是不是素数
    函数名参考：isPrime

3. 写一个函数，该函数用于对数组求和
    函数名参考：sumOfArray

4. 写一个函数，该函数用于得到数组中的最大值
    函数名参考：maxOfArray

5. 写一个函数，该函数用于得到数组中的最小值
    函数名参考：minOfArray

6. 写一个函数，该函数用于判断数组是否是稀松数组
    函数名参考：hasEmptyInArray

7. 写一个函数，判断该某年是否是闰年
    函数名参考：isLeap

8. 写一个函数，得到某年某月的天数
    函数名参考：getDays

9. 写一个函数，得到某个数字数组中出现次数最多的数字和频率
    函数名参考：getTopFreqInArray
```

**函数使用**

```
1. 利用上面的某些函数，实现哥德巴赫猜想
    任一大于2的偶数都可写成两个质数之和，比如：8 = 3 + 5
    让用户输入一个大于2的整数，输出其等于哪两个素数相加

2. 让用户输入一个年份，输出该年每个月的天数
```

### test.html

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2020年9月13日</title>
</head>

<body>
    <script src="./Myfunctions.js"></script>

    <!-- test1.html -->
    <script>
        function printSplitor() {
            console.log("********************"); //输出分隔符
        }
        // 如果两个script脚本块调换位置 那么函数将无法正常调用 [函数提升不会跨脚本块]
    </script>

    <script>
        printSplitor(); // ********************
        // 函数体的代码不会直接运行，必须要手动调用函数，才能运行其中的代码。
        console.log("asdfasdfa");
        console.log(234);
        printSplitor(); // ********************
        console.log({
            x: 234,
            y: "asdf"
        });
        console.log("344535");
        printSplitor(); // ********************
        console.log(window.printSplitor); // 通过字面量声明的函数，会成为全局对象的属性。
    </script>

    <script>
        printSplitor(); // ********************
        // 函数声明整体提升 ==> 在函数声明之前可以正常调用函数
        function printSplitor() {
            console.log("********************"); //输出分隔符
        }
        // 如果两个script脚本块调换位置 那么函数将无法正常调用 [函数提升不会跨脚本块]
    </script>


    <!-- test2.html -->
    <!-- 在局部作用域声明全局变量 -->
    <script>
        console.log(typeof test); // "function"

        function test() {
            a = 3;
            console.log(a); // 3
            console.log(a === window.a); // true
        }
        test(); // 函数执行后 为全局对象 window 添加了一个属性 a 值是 3
        console.log(a); // 3
        console.log(a === window.a); // true
    </script>

    <!-- 在局部作用域声明局部变量 -->
    <script>
        function test() {
            // var a; ==> 变量声明提升到所在函数的顶部
            console.log(a); // undefined
            var a = 3;
            a--; // AO 的a ==> 2
            console.log(a); // 2
            console.log(a === window.a); // false
        }
        var a = 5; // GO 的a ==> 5
        test();
        console.log(a); // 5
        console.log(a === window.a); // true
    </script>

    <!-- test3.html -->
    <!-- 参数的形式 -->
    <script>
        function isOdd(n) { // 形参
            // 参数 n 的有效区域在函数体中
            if (n % 2 === 0) {
                console.log(n + "不是奇数");
            } else {
                console.log(n + "是奇数");
            }
        }

        // 如果实参没有传递，则对应的形参为undefined
        isOdd(); // undefined是奇数

        var nums = [324, 4, 2, 1, 3, 45, 332];
        for (var i = 0; i < nums.length; i++) {
            isOdd(nums[i]); // 实参 nums[i]
        }

        isOdd(3); // 实参 3
        isOdd(100 + 3 * 4); // 实参 100 + 3 * 4 实参也可以是一个表达式
    </script>

    <!-- 参数的个数 -->
    <script>
        // 输出两个数相加的结果
        function sum(a, b) {
            console.log(`${a}+${b}=${a+b}`);
        }

        sum(234); // 参数传少了 未传的是 undefined ==> 234+undefined=NaN
        sum(3, 5); // 3+5=8
        sum(234, 234, 435345, 4352); // 参数传多了 多传的直接忽略 ==> 234+234=468
    </script>

    <!-- 对一个数组求和 -->
    <script>
        function sumOfArray(arr) {
            var sum = 0;
            for (var i = 0; i < arr.length; i++) {
                sum += arr[i];
            }
            console.log("和为：" + sum);
        }

        sumOfArray([32, 4, 5, 32, 1]); // 和为：74
        var nums = [345, 43, 45, 23, 234, 234, 423, 435, 435, 435];
        sumOfArray(nums); // 和为：2652
    </script>

    <!-- 删除数组末尾的指定数量的数据 -->
    <script>
        function deleteArray(arr, number) {
            arr.splice(-number, number);
        }
        var nums = [1, 2, 3, 4, 5];
        deleteArray(nums, 3); // nums 引用传递 传的是地址

        console.log(nums); // (2) [1, 2]
    </script>


    <!-- test4.html -->
    <!-- 判奇数 -->
    <script>
        function isOdd(n) {
            if (n % 2 === 0) {
                return false;
            }
            return true;
        }
    </script>

    <!-- 数组中奇数求和 -->
    <script>
        var nums = [1, 2, 3, 4, 5, 6, 7, 8];
        var sum = 0;
        for (var i = 0; i < nums.length; i++) {
            if (isOdd(nums[i])) { // 直接调用上面声明好的函数
                sum += nums[i];
            }
        }
        console.log(sum); // 16
    </script>




    <!-- test5.html -->
    <!-- 对一个数组求和 -->
    <script>
        function sumOfArray(arr) {
            var sum = 0;
            for (var i = 0; i < arr.length; i++) {
                sum += arr[i];
            }
            return sum;
        }

        var num1 = [1, 2, 3, 4];
        var num2 = [5, 6, 7];

        console.log(sumOfArray(num1) + sumOfArray(num2)); // 28
    </script>

    <!-- 判断一个数是不是素数 -->
    <script>
        function isPrime(n) {
            if (n < 3) {
                return n > 1;
            }
            for (var i = 2; i < n - 1; i++) {
                if (n % i === 0) {
                    return false;
                }
            }
            return true;
        }
    </script>

    <!-- 对数组nums中的素数求和 -->
    <script>
        var nums = [1, 2, 3, 4, 5, 6, 7];
        var sum = 0;
        for (var i = 0; i < nums.length; i++) {
            if (isPrime(nums[i])) {
                sum += nums[i];
            }
        }
        console.log(sum); // 17 ==> 2 + 3 + 5 + 7
    </script>


    <!-- test6.js -->
    <script>
        /**
         * nums：一个数字的数组
         */
        var nums = [23, 56, 65, 746];

        /**
         * 两个求和
         * @param {number} a 第一个数字
         * @param {number} b 第二个数字
         * @returns {number} 相加的结果
         */
        function sum(a, b) {
            return a + b;
        }

        /**
         * 判断一个数是不是素数
         * @param {number} n 要判断的数
         * @returns {boolean} 是否是素数
         */
        function isPrime(n) {
            //..
        }

        var s = sum(1, 3);
    </script>


    <!-- ====================================================================== -->

    <!-- 作业部分 -->

    <!-- isOdd -->
    <script>
        var Myfunctions = {
            isOdd: function (num) {
                return num % 2 !== 0;
            }
        }
    </script>

    <script>
        console.log(Myfunctions.isOdd(2)); // false
        console.log(Myfunctions.isOdd(32)); // false
        console.log(Myfunctions.isOdd(11)); // true
        console.log(Myfunctions.isOdd(27)); // true
    </script>

    <!-- isPrime -->
    <script>
        var Myfunctions = {
            isPrime: function (num) {
                if (num <= 3) {
                    return num > 1;
                }
                for (var i = 2; i <= num - 1; i++) {
                    if (num % i === 0) {
                        return false;
                    }
                }
                return true;
            }
        }
    </script>

    <script>
        var arr = [];
        for (var i = 0; i < 100; i++) {
            arr[i] = i + 1;
        }
        var sum = 0;
        var newArr = [];
        for (var i = 0; i < 100; i++) {
            if (Myfunctions.isPrime(arr[i])) {
                sum += arr[i];
                newArr.push(arr[i]);
            }
        }
        console.log(`1~100中共有 ${newArr.length} 个素数\t ${newArr} \t总和为 ${sum} `);
        // 1~100中共有 25 个素数	 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97
        // 总和为 1060
    </script>

    <!-- sumOfArray -->
    <script>
        var Myfunctions = {
            sumOfArray: function (arr) {
                var sum = 0;
                for (var i = 0; i < arr.length; i++) {
                    sum += arr[i];
                }
                return sum;
            }
        }
    </script>

    <script>
        var arr = [];
        for (var i = 0; i < 100; i++) {
            arr[i] = i + 1;
        }
        var sum = Myfunctions.sumOfArray(arr);
        console.log(sum); // 5050
    </script>


    <!-- maxOfArray -->
    <script>
        var Myfunctions = {
            maxOfArray: function (arr) {
                var max = arr[0];
                for (var i = 1; i < arr.length; i++) {
                    if (arr[i] > max) {
                        max = arr[i];
                    }
                }
                return max;
            }
        }
    </script>

    <script>
        var arr = [32, 13, 46, 73, 25, 62];
        var maxNum = Myfunctions.maxOfArray(arr);
        console.log(maxNum); // 73
    </script>


    <!-- minOfArray -->
    <script>
        var Myfunctions = {
            minOfArray: function (arr) {
                var min = arr[0];
                for (var i = 1; i < arr.length; i++) {
                    if (arr[i] < min) {
                        min = arr[i];
                    }
                }
                return min;
            }
        }
    </script>

    <script>
        var arr = [32, 13, 46, 73, 25, 62];
        var minNum = Myfunctions.minOfArray(arr);
        console.log(minNum); // 13
    </script>


    <!-- hasEmptyInArray -->
    <script>
        var Myfunctions = {
            hasEmptyInArray: function (arr) {
                for (var i = 0; i < arr.length; i++) {
                    if (!(i in arr)) {
                        return true;
                    }
                }
                return false;
            }
        }
    </script>

    <script>
        var arr1 = [, , , 2, 3, 4, , 1];
        var arr2 = [];
        arr2[10] = 1;
        var arr3 = new Array(100);
        var arr4 = [1, 2, 3, 4, 5];
        console.log(Myfunctions.hasEmptyInArray(arr1)); // true
        console.log(Myfunctions.hasEmptyInArray(arr2)); // true
        console.log(Myfunctions.hasEmptyInArray(arr3)); // true
        console.log(Myfunctions.hasEmptyInArray(arr4)); // false
    </script>



    <!-- isLeap -->
    <script>
        var Myfunctions = {
            isLeap: function (year) {
                return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
            }
        }
    </script>

    <script>
        console.log(1999); // false
        console.log(2020); // true
    </script>


    <!-- getDays -->
    <script>
        var Myfunctions = {
            getDays: function (year, month) {
                if (this.isLeap(year) && month === 2) {
                    return 29;
                } else if (!this.isLeap(year) && month === 2) {
                    return 28;
                } else if ((this.isOdd(month) && month < 8) || (!this.isOdd(month) && month >= 8)) {
                    return 31;
                } else {
                    return 30;
                }
            }
        }
    </script>

    <script>
        for (var i = 0; i < 12; i++) {
            console.log(`2020 - ${i+1}月 共有 ${Myfunctions.getDays(2020, i + 1)}天`);
        }
    </script>


    <!-- getTopFreqInArray -->
    <script>
        var Myfunctions = {
            /**
             * 获取数组中出现频率最高的数 及其出现次数
             * @param {*} arr
             * @return {Object} {num: 出现最多的数, fre: 该数出现的次数}
             */
            getTopFreqInArray: function (arr) {
                var recordObj = {};
                for (var i = 0; i < arr.length; i++) {
                    if (arr[i] in recordObj) {
                        recordObj[arr[i]]++;
                    } else {
                        recordObj[arr[i]] = 1;
                    }
                }
                var resultObj = {
                    num: arr[0],
                    fre: recordObj[arr[0]]
                };
                for (var i = 0; i < arr.length; i++) {
                    if (resultObj.fre < recordObj[arr[i]]) {
                        resultObj.num = arr[i];
                        resultObj.fre = recordObj[arr[i]];
                    }
                }
                return resultObj;
            }
        }
    </script>

    <script>
        var arr = [1, 5, 3, 3, 5, 2, 4, 3, 5, 5];
        var result = Myfunctions.getTopFreqInArray(arr);
        console.log(result); // {num: 5, fre: 4}
    </script>



    <!-- 哥德巴赫猜想 -->
    <script>
        var inputNum = +prompt('请输入一个大于2的偶数: ');
        if (isNaN(inputNum) || Myfunctions.isOdd(inputNum)) {
            console.log("输入错误");
        } else {
            for (var i = 1; i < inputNum; i++) {
                var j = inputNum - i;
                if (Myfunctions.isPrime(i) && Myfunctions.isPrime(j)) {
                    console.log(`${inputNum} = ${i} + ${j}`);
                }
            }
        }
    </script>


    <!-- 根据用户输入的年份 ==> 打印这一年每个月的天数 -->
    <script>
        var inputYear = +prompt('请输入一个年份: ');
        for (var i = 0; i < 12; i++) {
            console.log(`${inputYear} - ${i+1}月 共有 ${Myfunctions.getDays(inputYear, i + 1)}天`);
        }
    </script>
</body>

</html>
```

**Myfunctions.js**

```js
var Myfunctions = {
    /**
     * 判奇数
     * @param {*} num
     */
    isOdd: function (num) {
        return num % 2 !== 0;
    },
    /**
     * 判素数
     * @param {*} num
     */
    isPrime: function (num) {
        if (num <= 3) {
            return num > 1;
        }
        for (var i = 2; i <= num - 1; i++) {
            if (num % i === 0) {
                return false;
            }
        }
        return true;
    },
    /**
     * 数组求和
     * @param {*} arr
     */
    sumOfArray: function (arr) {
        var sum = 0;
        for (var i = 0; i < arr.length; i++) {
            sum += arr[i];
        }
        return sum;
    },
    /**
     * 返回数组中的最大值
     * @param {*} arr
     */
    maxOfArray: function (arr) {
        var max = arr[0];
        for (var i = 1; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        return max;
    },
    /**
     * 返回数组中的最小值
     * @param {*} arr
     */
    minOfArray: function (arr) {
        var min = arr[0];
        for (var i = 1; i < arr.length; i++) {
            if (arr[i] < min) {
                min = arr[i];
            }
        }
        return min;
    },
    /**
     * 判稀松数组
     * @param {*} arr
     */
    hasEmptyInArray: function (arr) {
        for (var i = 0; i < arr.length; i++) {
            if (!(i in arr)) {
                return true;
            }
        }
        return false;
    },
    /**
     * 判闰年
     * @param {*} year
     */
    isLeap: function (year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    },
    /**
     * 返回指定年月的天数
     * @param {*} year
     * @param {*} month
     */
    getDays: function (year, month) {
        if (this.isLeap(year) && month === 2) {
            return 29;
        } else if (!this.isLeap(year) && month === 2) {
            return 28;
        } else if ((this.isOdd(month) && month < 8) || (!this.isOdd(month) && month >= 8)) {
            return 31;
        } else {
            return 30;
        }
    },
    /**
     * 获取数组中出现频率最高的数 及其出现次数
     * @param {*} arr
     * @return {Object} {num: 出现最多的数, fre: 该数出现的次数}
     */
    getTopFreqInArray: function (arr) {
        var recordObj = {};
        for (var i = 0; i < arr.length; i++) {
            if (arr[i] in recordObj) {
                recordObj[arr[i]]++;
            } else {
                recordObj[arr[i]] = 1;
            }
        }
        var resultObj = {
            num: arr[0],
            fre: recordObj[arr[0]]
        };
        for (var i = 0; i < arr.length; i++) {
            if (resultObj.fre < recordObj[arr[i]]) {
                resultObj.num = arr[i];
                resultObj.fre = recordObj[arr[i]];
            }
        }
        return resultObj;
    }
}
```

## 2. [作业讲解]函数语法

### test.html

```html
<!-- # 通用函数编写

新建一个js文件，编写以下函数 -->

<script src="../1. 函数语法/Myfunctions.js"></script>
<!-- Mr. Yuan 编写的代码位于 common 文件夹中的 myfunction.js 文件内部 -->



<!-- 1. 写一个函数，该函数用于判断某个数是不是奇数

函数名参考：isOdd -->
<!-- Mr. Tao -->
<script>
    /**
     * 判奇数
     * @param {number} num 被判断的数字
     * @return {boolean} 是奇数返回true 不是奇数返回 false
     */
    function isOdd(num) {
        return num % 2 !== 0;
    }
</script>
<!-- Mr. Yuan -->
<script>
    /**
     * 判断一个数是不是奇数
     * @param {number} n 要判断的数字
     * @returns {boolean}
     */
    function isOdd(n) {
        return n % 2 !== 0;
    }
</script>
<script>
    console.log(isOdd(1)); // true
    console.log(isOdd(10)); // false
</script>




<!-- 2. 写一个函数，该函数用于判断某个数是不是素数

函数名参考：isPrime -->
<!-- Mr. Tao -->
<script>
    /**
     * 判素数
     * @param {num} num 被判断的数字
     * @return {boolean} 是素数 ==> true 非素数 ==> false
     */
    function isPrime(num) {
        if (num < 3) {
            return num > 1;
        }
        for (var i = 2; i <= num - 1; i++) {
            if (num % i === 0) {
                return false;
            }
        }
        return true;
    }
</script>
<!-- Mr. Yuan -->
<script>
    /**
     * 判断一个数是不是素数
     * @param {*} n
     */
    function isPrime(n) {
        if (n < 2) {
            return false;
        }
        for (var i = 2; i < n; i++) {
            if (n % i === 0) {
                return false;
            }
        }
        return true;
    }
</script>
<script>
    var arr = [];
    // 初始化 arr 赋值 1~100
    for (var i = 0; i < 100; i++) {
        arr[i] = i + 1;
    }
    // 遍历 arr 求素数和
    var sum = 0;
    for (var i = 0; i < 100; i++) {
        if (isPrime(arr[i])) {
            sum += arr[i];
        }
    }
    console.log(sum); // 1060
</script>




<!-- 3. 写一个函数，该函数用于对数组求和

函数名参考： sumOfArray -->
<!-- Mr. Tao -->
<script>
    /**
     * 对数组求和
     * @param {Array} arr 求和的数组
     * @return {Number} 返回求和的结果
     */
    function sumOfArray(arr) {
        var sum = 0;
        for (var i = 0; i < arr.length; i++) {
            sum += arr[i];
        }
        return sum;
    }
</script>
<!-- Mr. Yuan -->
<script>
    /**
     * 对数组求和
     * @param {*} arr
     */
    function sumOfArray(arr) {
        var sum = 0;
        for (var i = 0; i < arr.length; i++) {
            sum += arr[i];
        }
        return sum;
    }
</script>
<script>
    var nums = [11, 26, 2, 38, 61];
    console.log(sumOfArray(nums)); // 138
</script>





<!-- 4. 写一个函数，该函数用于得到数组中的最大值

函数名参考：maxOfArray -->
<!-- Mr. Tao -->
<script>
    /**
     * 返回数组中的最大值 若数组长度是0 则返回 undefined
     * @param {Array} arr
     */
    function maxOfArray(arr) {
        if (arr.length === 0) {
            return;
        }
        maxNum = arr[0];
        for (var i = 1; i < arr.length; i++) {
            if (arr[i] > maxNum) {
                maxNum = arr[i];
            }
        }
        return maxNum;
    }
</script>
<!-- Mr. Yuan -->
<script>
    /**
     * 得到数组中的最大值，如果数组长度为0，则返回undefined
     * @param {*} arr
     */
    function maxOfArray(arr) {
        if (arr.length === 0) {
            return;
        }
        var max = arr[0];
        for (var i = 1; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        return max;
    }
</script>
<script>
    var nums = [11, 26, 2, 38, 61];
    console.log(maxOfArray(nums)); // 61
</script>




<!-- 5. 写一个函数，该函数用于得到数组中的最小值

函数名参考：minOfArray -->
<!-- Mr. Tao -->
<script>
    /**
     * 返回数组中的最小值 若数组长度是0 则返回 undefined
     * @param {Array} arr
     */
    function minOfArray(arr) {
        if (arr.length === 0) {
            return;
        }
        minNum = arr[0];
        for (var i = 1; i < arr.length; i++) {
            if (arr[i] < minNum) {
                minNum = arr[i];
            }
        }
        return minNum;
    }
</script>
<!-- Mr. Yuan -->
<script>
    /**
     * 得到数组中的最小值，如果数组长度为0，则返回undefined
     * @param {*} arr
     */
    function minOfArray(arr) {
        if (arr.length === 0) {
            return;
        }
        var min = arr[0];
        for (var i = 1; i < arr.length; i++) {
            if (arr[i] < min) {
                min = arr[i];
            }
        }
        return min;
    }
</script>
<script>
    var nums = [11, 26, 2, 38, 61];
    console.log(minOfArray(nums)); // 2
</script>




<!-- 6. 写一个函数，该函数用于判断数组是否是稀松数组

函数名参考：hasEmptyInArray -->
<!-- Mr. Tao -->
<script>
    /**
     * 判稀松数组
     * @param {Array} arr
     * @return {Boolean} 是稀松数组 ==> true 非稀松数组 ==> false
     */
    // 稀疏数组 就是包含从0开始的不连续索引的数组。
    function hasEmptyInArray(arr) {
        for (var i = 0; i < arr.length; i++) {
            if (!(i in arr)) {
                return true;
            }
        }
        return false;
    }
</script>
<!-- Mr. Yuan -->
<script>
    /**
     * 判断一个数组是不是稀松数组
     * @param {*} arr
     */
    function hasEmptyInArray(arr) {
        // 稀松数组的特点：下标连续
        for (var i = 0; i < arr.length; i++) {
            if (!(i in arr)) {
                return true;
            }
        }
        return false;
    }
</script>
<script>
    console.log(hasEmptyInArray(new Array(3))); // true
    console.log(hasEmptyInArray([3, 4, 2, 6])); // false
</script>




<!-- 7. 写一个函数，判断该某年是否是闰年

函数名参考：isLeap -->
<!-- Mr. Tao -->
<script>
    /**
     * 判闰年
     * @param {number} year 年份
     */
    function isLeap(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }
</script>
<!-- Mr. Yuan -->
<script>
    /**
     * 判断某年是不是闰年
     * @param {*} year
     */
    function isLeap(year) {
        // 4年一闰，百年不闰；400年一闰
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
</script>
<script>
    console.log(isLeap(2019));
    console.log(isLeap(2020));
</script>



<!-- 8. 写一个函数，得到某年某月的天数

函数名参考：getDays -->
<!-- Mr. Tao -->
<script>
    /**
     * 计算某年某月的天数
     * @param {number} year 年份
     * @param {number} month 月份
     * @return {number} 某年某月的天数
     */
    function getDays(year, month) {
        if (month === 2) {
            // 闰年 ==> 2月 ==> 29天
            return isLeap(year) ? 29 : 28;
        } else {
            if ((month < 8 && isOdd(month)) || (month >= 8 && !isOdd(month))) {
                // 大月
                return 31;
            } else {
                // 小月
                return 30;
            }
        }
    }
</script>
<!-- Mr. Yuan -->
<script>
    /**
     * 得到某年某月的天数
     * @param {*} year
     * @param {*} month
     */
    function getDays(year, month) {
        if (month === 2) {
            return isLeap(year) ? 29 : 28;
        } else if (month < 8 && isOdd(month) || month >= 8 && !isOdd(month)) {
            return 31;
        } else {
            return 30;
        }
    }
</script>
<script>
    console.log(getDays(2020, 2)); // 29
    console.log(getDays(2020, 9)); // 30
</script>





<!-- 9. 写一个函数，得到某个数字数组中出现次数最多的数字和频率

函数名参考：getTopFreqInArray -->
<!-- Mr. Tao - 1 -->
<script>
    /**
     * 得到某个数字数组中出现次数最多的数字和频率
     * @param {Array} arr
     * @return {Object} key ==> 出现最多的数字 value ==> 出现的次数
     */
    function getTopFreqInArray(arr) {

        // 记录对象
        var obj = {};
        for (var i = 0; i < arr.length; i++) {
            if (obj[arr[i]]) {
                obj[arr[i]]++;
            } else {
                obj[arr[i]] = 1;
            }
        }
        // 结果对象
        // console.log(obj);
        var maxFre = obj[arr[0]],
            maxFreIndex = 0;
        for (var i = 1; i < arr.length; i++) {
            if (maxFre < obj[arr[i]]) {
                maxFreIndex = i;
                maxFre = obj[arr[i]];
            }
        }
        var resultObj = {
            num: +arr[maxFreIndex],
            fre: maxFre
        }
        return resultObj;
    }
</script>
<!-- Mr. Tao - 2 -->
<script>
    function getTopFreqInArray(arr) {
        var recordObj = {}; // 记录
        for (var i = 0; i < arr.length; i++) {
            if (recordObj[arr[i]]) {
                recordObj[arr[i]]++;
            } else {
                recordObj[arr[i]] = 1;
            }
        }
        // console.log(recordObj);
        var resultObj = {
            maxNum: arr[0],
            maxFre: recordObj[arr[0]]
        }; // 结果
        console.log();
        for (prop in recordObj) {
            if (recordObj[prop] > resultObj.maxFre) {
                resultObj = {
                    maxNum: prop,
                    maxFre: recordObj[prop]
                }
            }
        }
        return resultObj;
    }
</script>
<!-- Mr. Yuan -->
<script>
    /**
     * 得到数组中出现频率最高的数字和频率
     * 返回一个对象
     * @param {*} arr
     */
    function getTopFreqInArray(arr) {
        var records = {}; //记录出现频率
        for (var i = 0; i < arr.length; i++) {
            var n = arr[i];
            if (records[n]) {
                records[n]++;
            } else {
                records[n] = 1;
            }
        }
        var result; //记录最终结果的对象
        for (var prop in records) {
            if (!result || records[prop] > result.frequency) {
                result = {
                    number: +prop,
                    frequency: records[prop]
                };
            }
        }
        return result;
    }
</script>
<script>
    var arr = [1, 3, 2, 6, 6, 6, 7, 5, 2, 3];
    var obj = getTopFreqInArray(arr);
    console.log(`出现最多的数字是: ${obj.num}\t出现的次数是: ${obj.fre}次`);
</script>




<!-- =============================================== -->


<!-- # 函数使用 -->




<!-- 1. 利用上面的某些函数，实现哥德巴赫猜想

任一大于2的偶数都可写成两个质数之和，比如：8 = 3 + 5

让用户输入一个大于2的偶数，输出其等于哪两个素数相加 -->
<!-- Mr. Tao -->
<script>
    var inputNum = +prompt("请输入一个大于2的偶数: ");
    if (inputNum > 2) {
        // 随机生成两个满足条件的素数
        while (true) {
            var primeNum1 = Math.ceil(Math.random() * inputNum),
                primeNum2 = inputNum - primeNum1;
            if (isPrime(primeNum1) && isPrime(primeNum2)) {
                break;
            } else {
                continue;
            }
        }
        console.log(`${inputNum}=${primeNum1}+${primeNum2}`);
    } else {
        console.log("输入错误");
    }
</script>
<!-- Mr. Yuan 1.html -->
<script>
    function begin() {
        var num = +prompt("请输入一个大于2的偶数");
        if (isNaN(num) || num <= 2 || isOdd(num)) {
            console.log("输入有误");
            return;
        }
        //输入正确
        for (var i = 2; i <= num - 2; i++) {
            var j = num - i;
            //判断两个数字是否都是素数
            if (isPrime(i) && isPrime(j)) {
                console.log(`${num} = ${i} + ${j}`);
            }
        }
    }

    begin();
</script>


<!-- 2. 让用户输入一个年份，输出该年每个月的天数 -->
<!-- Mr. Tao -->
<script>
    var inputYear = +prompt("请输入一个年份: ");
    var sum = 0; // 统计这一年的总天数
    for (var i = 1; i <= 12; i++) {
        console.log(`${inputYear}年的${i}月 ==> ${getDays(inputYear, i)}天`);
        sum += getDays(inputYear, i);
    }
    console.log(`${inputYear}年的总天数 ==> ${sum}天`);
</script>
<!-- Mr. Yuan 2.html -->
<script>
    // function begin() {
    //     var year = +prompt("请输入一个年份（1990~2100）");
    //     if (isNaN(year) || year < 1990 || year > 2100) {
    //         console.log("输入有误");
    //         return;
    //     }
    //     //输入正确
    //     for (var m = 1; m <= 12; m++) {
    //         console.log(`${year}年${m}月：${getDays(year, m)}`);
    //     }
    // }

    // begin();

    (function begin() {
        var year = +prompt("请输入一个年份（1990~2100）");
        if (isNaN(year) || year < 1990 || year > 2100) {
            console.log("输入有误");
            return;
        }
        //输入正确
        for (var m = 1; m <= 12; m++) {
            console.log(`${year}年${m}月：${getDays(year, m)}`);
        }
    }());
</script>
```

## 3. 作用域和闭包

**作用域**

```
目前只介绍两种作用域 学到ES6后 再介绍第3种作用域
作用域表示一个代码区域，也表示一个运行环境
JS中，有两种作用域：
    1. 全局作用域
       直接在脚本中书写的代码
       在全局作用域中声明的变量，会被提升到脚本块的顶部，并且会成为全局对象的属性。
    2. 函数作用域
       函数中的代码
       在函数作用域中声明的变量，会被提升到函数的顶部，并且不会成为全局对象的属性.
       因此，函数中声明的变量不会导致全局对象的污染
       尽量的把功能封装在函数中
       但是，当函数成为一个表达式时，它既不会提升，也不会污染全局对象。
       将函数变为一个函数表达式的方式之一，将函数用小括号括起来。
       然而，这样一来，函数无法通过名称调用。
       如果书写一个函数表达式，然后将立即调用，该函数称之为立即执行函数 IIFE（Imdiately Invoked Function Expression）。
       由于大部分情况下，函数表达式的函数名没有实际意义，因此，可以省略函数名。
       没有名字的函数，称之为匿名函数
```

**作用域中可以使用的变量**

```
全局作用域只能使用全局作用域中声明的变量（包括函数）
函数作用域不仅能使用自身作用域中声明的变量（包括函数），还能使用外部环境的变量（包括函数）
注意: 外部环境 ≠ window
有的时候，某个函数比较复杂，在编写的过程，可能需要另外一些函数来辅助它完成一些功能，而这些函数仅仅会被该函数使用，不会在其他位置使用，则可以将这些函数声明到该函数的内部。
函数内部声明的变量和外部冲突时，使用内部的。
```

**闭包**

```
闭包(closure), 是一种现象，内部函数，可以使用外部函数环境中的变量。
```

### test.html

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2020年9月13日</title>
</head>

<body>

    <!-- test1.html -->
    <script>
        // var a, b;
        var a = 234;
        var b = "234234";

        function test() {
            // var c, d;
            var c = 2342;
            var d = "345345345";
        }

        test();

        console.log("a" in window); // true
        console.log("b" in window); // true
        console.log("c" in window); // false
        console.log("d" in window); // false
    </script>

    <!-- test2.html -->
    <script>
        // 函数表达式 不会污染全局对象 window
        (function test() {
            var a = 1,
                b = 2,
                c = 3;
            console.log(a, b, c);
        });
        // test(); // test in not defined at ...
    </script>

    <script>
        // 立即执行函数
        (function () {
            var a = 1,
                b = 2,
                c = 3;
            console.log(a, b, c);
        }()); // () 可以放里面 也可以放外面
    </script>

    <script>
        // 立即执行函数
        (function () {
            var a = 1,
                b = 2,
                c = 3;
            console.log(a, b, c);
        })(); // () 可以放里面 也可以放外面
    </script>

    <!-- test3.html -->
    <script>
        // 里面的可以拿到外面的 外面的无法拿到里面的
        var g = "Abc";

        function A() {
            var a = 234;
            console.log(a, g); // 234 Abc

            function B() {
                var b = 567;
                console.log(b, a, g); // 567 234 Abc
            }

            B();
        }

        A();
    </script>





    <!-- test4.html -->
    <!-- 函数内可嵌套函数 -->
    <script>
        (function () {

            // 非常复杂，需要声明函数完成功能

            function helper1() {

            }

            function helper2() {

            }
        })();
    </script>

    <!-- test5.html -->
    <script>
        // 函数内部声明的变量和外部冲突时，使用内部的。
        // [这一块的内容比较复杂 在进阶课程会详细讲解]
        var test = "Asdfasf";
        var a = "abc";

        function B() {
            console.log('window');
        }

        function A() {
            var a = 'bcd';
            console.log(test); // "Asdfasf"
            function B() {
                console.log(a); // "bcd"
            }
            B();
        }

        A();
    </script>

    <script>
        var a = 0;

        function A() {
            var a = 1;

            function B() {
                console.log(a); // 1
                // 内部函数B 使用外部函数A 中的变量a
            }
            B();
        }
        A();
    </script>
</body>

</html>
```

## 4. 函数表达式和this

**函数表达式**

```
JS中，函数也是一个数据，语法上，函数可以用于任何需要数据的地方
JS中，函数是一等公民
函数是一个引用类型，将其赋值给某个变量时，变量中保存的是函数的地址
函数表达式的函数名可以省略 因为没有意义 没啥用
函数表达式的值就是函数本身
函数表达式不会提升 but 函数声明会提升
```

**this关键字**

```
在全局作用域中，this关键字固定指向全局对象。
在函数作用域中，取决于函数是如何被调用的
函数直接调用，this指向全局对象
通过一个对象的属性调用，格式为对象.属性()或对象["属性"]()，this指向对象
注意: this无法赋值
```

### test.html

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2020年9月13日</title>
</head>

<body>
    <!-- test1.html -->
    <!-- 函数表达式 -->
    <script>
        var a; // 只提升了变量
        a(); // 函数声明不会提升 ==> 不可以在函数字面量之前调用函数 ==> a is not a function
        console.log(a); // undefined

        var a = function () { // 创建一个函数，将其赋值给变量a
            console.log("asdasdf");
        }
    </script>

    <script>
        var a = function () {
            console.log("asdasdf");
        }
        var b = a;
        console.log(a === b); // true
        b(); // asdasdf
    </script>

    <!-- 函数字面量 -->
    <script>
        a(); // 函数声明会提升 ==> 可以在函数字面量之前调用函数
        function a() {
            console.log("asdasdf");
        }
    </script>

    <script>
        function a() {
            console.log("asdasdf");
        }
        var b = a;
        console.log(a === b); // true
        b(); // asdasdf
    </script>


    <!-- test2.html -->
    <script>
        var obj = {
            a: "asfd",
            b: 234,
            c: function () {
                console.log("ccccc");
            },
            d: function () {
                console.log("dddd");
            }
        };

        console.log(obj.c, typeof obj.c); // f () {...} "function"

        var b = obj.c;
        b(); // ccccc
        obj.d(); // dddd
        // console.log ==> console 是一个对象 log 是该对象里面的一个属性 该属性的值是一个函数表达式
    </script>


    <!-- test3.html -->
    <script>
        var arr = [34, 45454, "Asdf", {}, function () {
            console.log("数组中的函数");
        }];

        var func = arr[4];
        func(); // "数组中的函数"
    </script>


    <!-- test4.html -->
    <!-- 回调函数 -->
    <script>
        function test(callback1, callback2) {
            console.log("test运行");
            callback1();
            callback2();
        }


        test(function () {
            console.log("1");
        }, function () {
            console.log("2");
        });
        // test(参数1,参数2);
        // 此时 参数1 和 参数2 都是函数表达式
        // 表达式的值就是函数本身
        // 就好比
        // var callback1 = function () {console.log("1");}
        // var callback2 = function () {console.log("2");}
    </script>

    <script>
        function test(obj) {
            obj.func1();
            obj.func2();
        }

        test({
            func1: function () {
                console.log("func1");
            },
            func2: function () {
                console.log("func2");
            }
        });
    </script>


    <!-- test5.html -->
    <!-- 在全局直接调用函数 -->
    <script>
        function test() {
            console.log(this);
        }

        var b = test;

        b(); // window
    </script>

    <!-- test6.html -->
    <!-- 通过对象的属性调用 -->
    <script>
        function test() {
            console.log(this);
        }

        var b = test;
        var arr = [b, test];
        arr[0](); // (2) [f, f]
        // this 指向数组 arr
    </script>

    <!-- [注意]在函数未被调用之前 this 的指向是未知的 this 的指向是在函数被调用的时候才确定的 -->
    <script>
        var obj = {
            a: function () {
                console.log(this);
            },
            b: {
                x: 2342,
                func: function () {
                    console.log(this);
                }
            }
        };

        obj.a(); // this ==> obj
        obj.b.func(); // this ==> obj.b
        var b = obj.a;
        b(); // this ==> window
    </script>


    <!-- test7.html -->
    <!-- 对象里面的函数建议不要拿出来放在全局中再调用 -->
    <script>
        var obj = {
            firstName: "袁",
            lastName: "进",
            age: 18,
            sayHello: function () {
                console.log(`我叫${this.firstName}${this.lastName}，今年${this.age}岁了`);
            }
        };
        var b = obj.sayHello;
        b(); // 我叫undefinedundefined，今年undefined岁了
    </script>

    <script>
        var obj = {
            firstName: "袁",
            lastName: "进",
            age: 18,
            sayHello: function () {
                console.log(`我叫${this.firstName}${this.lastName}，今年${this.age}岁了`);
            }
        };

        obj.sayHello(); // 我叫袁进，今年18岁了

        obj.firstName = "姬";
        obj.lastName = "成";
        obj.age = 108;
        obj.sayHello(); // 我叫姬成，今年108岁了
    </script>

    <!-- 写 this.firstName 而不直接写 obj.firstName 的原因 -->
    <script>
        var obj = {
            firstName: "袁",
            lastName: "进",
            age: 18,
            sayHello: function () {
                console.log(`我叫${this.firstName}${this.lastName}，今年${this.age}岁了`);
            }
        };

        var obj2 = obj;
        obj = 234;

        // 将变量保存一下 然后将它的值重新改变 这样的操作在开发中很常见
        obj.sayHello(); // Uncaught TypeError: obj.sayHello is not a function

        obj2.sayHello(); // 我叫袁进，今年18岁了
    </script>

    <script>
        var obj = {
            firstName: "袁",
            lastName: "进",
            age: 18,
            sayHello: function () {
                console.log(`我叫${obj.firstName}${obj.lastName}，今年${obj.age}岁了`);
            }
        };

        var obj2 = obj;
        obj = 234;

        obj2.firstName = "姬";
        obj2.lastName = "成";
        obj2.age = 108;
        obj2.sayHello(); // 我叫undefinedundefined，今年undefined岁了
    </script>
</body>

</html>
```

## 5. [作业讲解]函数表达式和this

```
新建一个BetterFunction.js,将之前的MyFunction.js改造成为单对象模式。
    注意: 函数调用处 需要在函数名前面加上 `this.`
本次作业的要点在于体验回调函数的使用
    就是把 事件处理函数a 以参数的形式 传递给另一个 事件处理函数b
    在 事件处理函数b 内部来调用 事件处理函数a
```

### test.html

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2020年9月13日</title>
</head>

<body>
    <!-- 2. 写一个函数，为数组排序 要考虑到这个数组的所有可能 ==> sort -->
    <script>
        var MyFunctions = {
            sort: function (arr, compare) {
                // 若没有自定义的比较规则 则使用如下默认规则
                if (!compare) {
                    compare = function (a, b) {
                        if (a > b) {
                            return 1;
                        } else if (a === b) {
                            return 0;
                        } else {
                            return -1;
                        }
                        // return  a - b;
                    }
                }
                for (var i = 1; i < arr.length; i++) {
                    for (var j = 0; j < arr.length - i; j++) {
                        if (compare(arr[j], arr[j + 1]) > 0) {
                            var temp = arr[j];
                            arr[j] = arr[j + 1];
                            arr[j + 1] = temp;
                        }
                    }
                }
            }
        }

        var arr = [{
                name: 'b',
                age: 18,
                weight: 66
            },
            {
                name: 'a',
                age: 21,
                weight: 70
            },
            {
                name: 'd',
                age: 20,
                weight: 59
            },
        ];
        // console.log(arr);

        // 按体重升序
        MyFunctions.sort(arr, function (a, b) {
            return a.weight - b.weight;
        })

        // 按年龄升序
        MyFunctions.sort(arr, function (a, b) {
            return a.age - b.age;
        })

        // 按姓名的字符编码 升序
        MyFunctions.sort(arr, function (a, b) {
            if (a.name > b.name) {
                return 1;
            } else if (a.name === b.name) {
                return 0;
            } else {
                return -1;
            }
        })

        /* 比较规则的多样性 */
        MyFunctions.sort(arr, function (a, b) {
            return (a.age + a.weight) - (b.age + b.weight);
        })
    </script>

    <!-- 3. 写一个函数，按照指定的条件对某个数组进行筛选 ==> filter -->
    <script>
        var MyFunctions = {
            filter: function (arr, callback) {
                var newArr = [];
                for (var i = 0; i < arr.length; i++) {
                    if (callback(arr[i], i)) {
                        newArr.push(arr[i]);
                    }
                }
                return newArr;
            }
        }

        // 返回是奇数的项
        var arr = [13, 452, 656, 34546, 32, 345, 143, 547, 357]
        var newArr = MyFunctions.filter(arr, function (item) {
            return item % 2 !== 0;
        });

        // 返回下标为奇数的项
        var arr = [13, 452, 656, 34546, 32, 345, 143, 547, 357]
        var newArr = MyFunctions.filter(arr, function (item, index) {
            return index % 2 !== 0;
        });

        // 返回是素数的数
        var arr = [13, 452, 656, 34546, 32, 345, 143, 547, 357];
        var newArr = MyFunctions.filter(arr, MyFunctions.isPrime);


        var arr = [13, 452, 656, 34546, 32, 345, 143, 547, 357]
        var newArr = MyFunctions.filter(arr, this.Prime);
    </script>

    <!-- 4. 写一个函数，按照指定的条件，得到某个数组中第一个满足条件的元素 ==> find -->
    <script>
        var MyFunctions = {
            find: function (arr, callback) {
                for (var i = 0; i < arr.length; i++) {
                    if (callback(arr[i], i)) {
                        return arr[i];
                    }
                }
            }
        };

        // 查找数组中第一个能被15整除的项
        var arr = [13, 452, 656, 34546, 32, 345, 143, 547, 357];
        var elm = MyFunctions.find(arr, function (item) {
            return item % 15 === 0;
        });

        // 查找数组中第一个素数
        var arr = [13, 452, 656, 34546, 32, 345, 143, 547, 357];
        var elm = MyFunctions.find(arr, function (num) {
            if (num === 1) {
                return false;
            }
            if (num === 2) {
                return true;
            }
            for (var i = 2; i < num; i++) {
                if (num % i === 0) {
                    return false;
                }
            }
            return true;
        });

        var arr = [13, 452, 656, 34546, 32, 345, 143, 547, 357];
        var elm = MyFunctions.find(arr, MyFunctions.isPrime);
    </script>

    <!-- 5. 写一个函数，按照指定的条件，得到某个数组中满足条件的元素数量 ==> count -->
    <script>
        var MyFunctions = {
            count: function (arr, callback) {
                var num = 0;
                for (var i = 0; i < arr.length; i++) {
                    if (callback(arr[i], i)) {
                        num++;
                    }
                }
                return num;
            }
        };

        // 统计数组中素数的个数
        var arr = [13, 452, 656, 34546, 32, 345, 143, 547, 357];
        var num = MyFunctions.count(arr, function (num) {
            if (num === 1) {
                return false;
            }
            if (num === 2) {
                return true;
            }
            for (var i = 2; i < num; i++) {
                if (num % i === 0) {
                    return false;
                }
            }
            return true;
        });

        var arr = [13, 452, 656, 34546, 32, 345, 143, 547, 357];
        var num = MyFunctions.find(arr, MyFunctions.isPrime);
    </script>
</body>

</html>
```

## 6. 构造函数

> 对象中的属性，如果是一个函数，也称该属性为对象的方法

**用于创建对象的函数**

用函数创建对象，可以减少繁琐的对象创建流程

1. 函数返回一个对象
2. 构造函数：构造函数专门用于创建对象

```js
new 函数名(参数);
```

如果使用上面的格式创建对象，则该函数叫做构造函数。

1) 函数名使用大驼峰命名法

> 构造函数的命名尽量不要出现 v.(动词) new 表示 创建 已经有一个动词了
> > new CreateUser(); ==> new User();

2) ==构造函数内部，会自动创建一个新对象，this指向新创建的对象，并且自动返回新对象==

> 可以理解为 `this = {}` // 当然 这样的写法显然是不对的 因为 this 不能被赋值 但是可以这么理解

3) 构造函数中如果出现返回值，如果返回的是原始类型，则直接忽略；如果返回的是引用类型，则使用返回的结果
4) 所有的对象，最终都是通过构造函数创建的


**new.target**

该表达式在函数中使用，返回的是当前的构造函数，但是，如果该函数不是通过new调用的，则返回undefined

通常用于判断某个函数是否是通过new在调用。

### test.html

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2020年9月17日</title>
</head>

<body>

    <!-- 创建一个用户 -->

    <!-- test1.html -->
    <script>
        function createUser(name, age, gender) {
            return {
                name, // name: name,
                age, // age: age,
                gender, // gender: gender,
                sayHello() { // sayHello: function() {...},
                    console.log(`我叫${this.name}，年龄${this.age}岁，性别${this.gender}`);
                }
            };
        }

        var u1 = createUser("张三", 18, "男");
        u1.sayHello(); // 我叫张三，年龄18岁，性别男
        var u2 = createUser("姬成", 20, "男");
        u2.sayHello(); // 我叫姬成，年龄20岁，性别男
        console.log(u1 === u2); // false
    </script>

    <!-- test2.html -->
    <script>
        function User(name, age, gender) {
            // 自动生成 this ==> 指向当前构造函数
            this.name = name;
            this.age = age;
            this.gender = gender;
            this.sayHello = function () {
                console.log(`我叫${this.name}，年龄${this.age}岁，性别${this.gender}`);
            }
            // return this;
        }

        var u1 = new User("张三", 18, "男");
        u1.sayHello(); // 我叫张三，年龄18岁，性别男
        var u2 = new User("姬成", 20, "男");
        u2.sayHello(); // 我叫姬成，年龄20岁，性别男

        console.log(u1 === u2); // false
    </script>



    <!-- test3.html -->
    <script>
        var arr = new Array(3, 4, 5);
    </script>

    <script>
        arr = [3, 5, 7, 2]; // 语法糖

        // 相当于

        var arr = new Array(3, 5, 7, 2);
    </script>

    <script>
        var obj = {
            name: "asdf",
            age: 234,
            gender: "男"
        };

        // 相当于

        var obj = new Object();
        obj.name = "asdf";
        obj.age = 234;
        obj.gender = "男";
    </script>



    <!-- test4.html -->
    <script>
        // 创建一个用户
        function User(name, age, gender) {
            var temp = function () {
                console.log(`我叫${this.name}，年龄${this.age}岁，性别${this.gender}`);
            };
            // 正常的构造函数调用
            if (new.target === User) {
                this.name = name;
                this.age = age;
                this.gender = gender;
                this.sayHello = temp;
            } else {
                // 构造函数当做普通函数调用 (兼容处理)
                return {
                    name,
                    age,
                    gender,
                    sayHello: temp
                }
            }
        }
        // 正常的构造函数调用
        var u1 = new User("ss", 18, "女");
        console.log(u1);
        // 将构造函数当做普通函数调用
        var u2 = User('sss', 108, '女');
        console.log(u2);

        // new Array(10);
        // Array(10);
        // 得到的结果是相同的 处理方式和这个User类似 加了一个 if-else 判断
    </script>
</body>

</html>
```

### 作业.html

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>2020年9月13日</title>
</head>

<body>
    <!-- Mr. Yuan -->
    <!-- 英雄打怪兽的小游戏

    英雄和怪兽都具有攻击力、防御力、生命值、暴击几率（暴击时伤害翻倍）

    攻击伤害 = 攻击力 - 防御力

    伤害最少为1.

    创建一个英雄和一个怪兽，让它们互相攻击，直到一方死亡，输出整个攻击过程。 -->
    <!-- <script src="./作业.js"></script> -->


    <!-- Mr. Tao -->
    <script>
        console.log("============游戏开始===========");

        function Charactor(name, attack, defence, hp, critRate) {
            this.name = name;
            this.attack = attack;
            this.defence = defence;
            this.hp = hp;
            this.critRate = critRate;

            this.print = function () {
                console.log(
                    `姓名: ${this.name} 攻击力: ${this.attack} 防御力: ${this.defence} 剩余生命值: ${this.hp} 暴击率: ${this.critRate}`
                );
            }

            this.hit = function (target) {
                var damage = this.attack - target.defence;

                // 判断是否有暴击
                var isCrit = this.critRate > Math.random();
                if (isCrit) {
                    damage *= 2;
                }

                // damage 最小是1
                if (damage < 1) {
                    damage = 1;
                }

                target.hp -= damage;

                if (target.hp < 0) {
                    target.hp = 0;
                }

                console.log(
                    `${isCrit ? "暴击！" : ""}【${this.name}】攻击【${target.name}】，造成【${damage}】点伤害，对方当前血量为【${target.hp}】`
                    );

                return target.hp === 0;
            }

        }

        var hero = new Charactor('hero', 100, 50, 1000, 0.5);
        hero.print();
        var monster = new Charactor('monster', 80, 70, 1100, 0.4);
        monster.print();

        while (1) {
            if (hero.hit(monster) || monster.hit(hero)) {
                break;
            }
        }

        hero.print();
        monster.print();

        console.log("============游戏结束===========");
    </script>
</body>

</html>
```

### 作业.js

```js
/**
 * 游戏角色的构造函数
 * @param {*} name 角色名
 * @param {*} attack 攻击力
 * @param {*} defence 防御力
 * @param {*} hp 生命值
 * @param {*} critRate 暴击率（0~100）
 */
function Charactor(name, attack, defence, hp, critRate) {
    this.name = name;
    this.attack = attack;
    this.defence = defence;
    this.hp = hp;
    this.critRate = critRate;

    //函数

    /**
     * 打印信息
     */
    this.print = function () {
        console.log(`${this.name}\t生命：${this.hp}\t攻击：${this.attack}\t防御：${this.defence}\t暴击率：${this.critRate}%`);
    }

    /**
     * 攻击，返回对方是否死亡
     * @param {*} ctor 攻击对象
     */
    this.hit = function (ctor) {
        var damage = this.attack - ctor.defence;
        //判断是否有暴击
        var rate = this.critRate / 100;
        var rad = Math.random();
        var isCrit = false; //是否暴击
        if (rad <= rate) {
            isCrit = true;
            //有暴击
            damage *= 2; //伤害翻倍
        }
        //伤害至少为1
        if (damage < 1) {
            damage = 1;
        }
        ctor.hp -= damage;
        if (ctor.hp < 0) {
            ctor.hp = 0;// 血量至少为0
        }
        console.log(`${isCrit ? "暴击！" : ""}【${this.name}】攻击【${ctor.name}】，造成【${damage}】点伤害，对方当前血量为【${ctor.hp}】`);
        //对方是否死亡
        return ctor.hp === 0;
    }
}
var hero = new Charactor("成哥", 100, 20, 500, 30);
hero.print();
console.log("VS");
var monster = new Charactor("邓哥", 120, 40, 400, 5);
monster.print();

while (true) {
    if (hero.hit(monster)) {
        break;
    }
    if (monster.hit(hero)) {
        break;
    }
}
console.log("=========================");
hero.print();
monster.print();
console.log("游戏结束");
```

## 7. 函数的本质


```
函数的本质就是对象。
某些教程中，将构造函数称之为构造器
所有的对象都是通过关键字new出来的，new 构造函数()
所有的函数，都是通过new Function创建。
由于函数本身就是对象，因此函数中，可以拥有各种属性。
```

**包装类**

```
JS为了增强原始类型的功能，为boolean、string、number分别创建了一个构造函数：
    1. Boolean
    2. String
    3. Number
如果语法上，将原始类型当作对象使用时（一般是在使用属性时），JS会自动在该位置利用对应的构造函数，创建对象来访问原始类型的属性。
```

```js
var a = 3.1415926535; // a 是原始类型 Number
console.log(a.toFixed(2)); // 将原始类型当做对象来使
// 等价于: console.log(new Number(3.1415926535).toFixed(2));
// 最终结果: 3.14
```

```
类：在JS中，可以认为，类就是构造函数
成员属性（方法）、实例属性（方法）：表示该属性是通过构造函数创建的对象调用的。
静态属性（方法）、类属性（方法）：表示该属性是通过构造函数本身调用的。
```

### test.html

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2020年9月17日</title>
</head>

<body>

    <!-- test1.html -->
    <script>
        function sum(a, b) {
            return a + b;
        }

        console.log(typeof sum); // "function"
        console.log(sum(3, 5)); // 8
    </script>

    <script>
        var sum = new Function("a", "b", "return a+b");

        console.log(typeof sum); // "function"
        console.log(sum(3, 5)); // 8
    </script>


    <!-- test2.html -->
    <script>
        function User(firstName, lastName) {
            this.firstName = firstName;
            this.lastName = lastName;
            this.fullName = this.firstName + " " + this.lastName;
        }

        console.log(new User("袁", "进")); // User {firstName: "袁", lastName: "进", fullName: "袁 进"}
    </script>


    <!-- test3.html -->
    <script>
        function User(firstName, lastName) {
            this.firstName = firstName;
            this.lastName = lastName;
            this.fullName = this.firstName + " " + this.lastName;
        }

        User.abc = 123;
        console.log(User.abc); // 123


        User.test = function () {
            console.log(this.abc);
        }
        User.test(); // 123
    </script>


</body>

</html>
```

## 8. 递归

```
函数直接或间接调用自身

避免无限递归，无限递归会导致执行栈溢出。

对比死循环

- 死循环不会报错，也不会导致栈溢出
- 无限递归会导致栈溢出
```

**执行栈**

```
任何代码的执行都必须有一个执行环境，执行环境为代码的执行提供支持

执行环境是放到执行栈中的。

每个函数的调用，都需要创建一个函数的执行环境，函数调用结束，执行环境销毁。

执行栈有相对固定的大小，如果执行环境太多，执行栈无法容纳，会报错
```

**尾递归**

```
如果一个函数最后一条语句是调用函数，并且调用函数不是表达式的一部分，则该语句称为尾调用，如果尾调用是调用自身函数，则称为尾递归。

某些语言或执行环境会对尾调用进行优化，它们会理解销毁当前函数，避免执行栈空间被占用。

在浏览器执行环境中，尾调用没有优化。但在nodejs环境中有优化。
```

### test.html

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2020年9月13日</title>
</head>

<body>
    <!-- 斐波拉契数列.html -->
    <script>
        //求斐波拉契数列第n位的值
        //1  1  2  3  5  8  13  21  ...
        //f(n) = f(n-1) + f(n-2)

        //斐波拉契数列的第n位
        function f(n) {
            if (n === 1 || n === 2) {
                return 1;
            }
            return f(n - 1) + f(n - 2);
        }

        console.log(f(5));
        // f(5) = f(4) + f(3)

        /* 下面开始求f(4) */
        // f(4) = f(3) + f(2)
        // f(3) = f(2) + f(1)
        // f(3) = 1 + f(1)
        // f(3) = 1 + 1
        // f(4) = 2 + f(2)
        // f(4) = 2 + 1
        // f(5) = 3 + f(3)

        /* 下面开始求f(3) */
        // f(3) = f(2) + f(1)
        // f(3) = 1 + f(1)
        // f(3) = 1 + 1
        // f(5) = 3 + 2
        // f(5) = 5
    </script>

    <!-- 执行栈.html -->
    <!-- 执行栈 call stack -->
    <script>
        // 一旦遇到函数调用 就会创建一个执行环境 结束后就销毁
        function A() {
            console.log("A begin"); // 2
            B();
            console.log("A over"); // 7
        }

        function B() {
            console.log("B begin"); // 3
            C();
            console.log("B over"); // 6
        }

        function C() {
            console.log("C begin"); // 4
            console.log("C over"); // 5
        }

        console.log("global begin"); // 1
        A();
        console.log("global over"); // 8
    </script>

    <!-- 阶乘.html -->
    <script>
        // 5! = 5*4*3*2*1
        // f(n)
        // f(1) = 1
        // f(2) = 2*f(1)
        // f(3) = 3*f(2)
        // n的阶乘 n!
        function fhelper(n, total) {
            if (n === 1) {
                return total;
            }
            // 注意递归的终止条件 若无限递归 则会溢出执行栈
            // Uncaught RangeError: Maximum call stack size exceeded
            return fhelper(n - 1, n * total);
        }

        function f(n) {
            return fhelper(n, 1);
        }

        console.log(f(5));

        // fhelper(5, 1) === fhelper(4, 5)
        // fhelper(4, 5) === fhelper(3, 20)
        // fhelper(3, 20) === fhelper(2, 60)
        // fhelper(2, 60) === fhelper(1, 120)
        // fhelper(1, 120) === 120
        // 尾递归优化: 最后一步直接返回结果
        // [but] 在浏览器中不会优化... 但在nodejs里面有
    </script>

    <!-- 无限循环和无限递归.html -->
    <script>
        // 死循环不会报错，也不会导致栈溢出 [会卡死 不会报错]
        function A() {
            while (true) {
                console.log("1");
            }
        }
        A();
    </script>

    <script>
        // 无限递归会导致栈溢出 [会报错 不会卡死]
        function A() {
            A();
        }

        A();
    </script>

    <!-- 汉诺塔.html -->
    <script>
        function hannuo(no1, no2, no3, n) {
            if (n === 1) {
                console.log(`${no1}->${no3}`);
            } else {
                hannuo(no1, no3, no2, n - 1);
                console.log(`${no1}->${no3}`);
                hannuo(no2, no1, no3, n - 1);
            }
        }

        hannuo('A', 'B', 'C', 5);
    </script>

</body>

</html>
```

