网络考试题

例1
1. 常见的HTTP状态码你了解多少？描述一下状态码的含义。

200
301
302
303
403
404
503
 
答：
1. 200 —— 表示服务器已经成功接受请求，并将返回客户端所请求的最终结果；
2. 301 —— 客户端请求的网页已经永久移动到新的位置，当链接发生变化时，返回301代码告诉客户端链接的变化，客户端保存新的链接，并向新的链接发出请求，已返回请求结果；
3. 302 —— 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI；
4. 303 —— 请求已经被处理，但服务器不是直接返回一个响应文档，而是返回一个响应文档的URI；
5. 403 —— 客户端请求的结构正确，但是服务器不想处理它；
6. 404 —— 请求失败，客户端请求的资源没有找到或者是不存在；
7. 503 —— 服务器由于临时的服务器过载或者是维护，无法解决当前的请求；
参考文章：
https://www.runoob.com/http/http-status-codes.html
https://www.cnblogs.com/xflonga/p/9368993.html


var xhr = null;
if (window.XMLHttpRequest) {
    xhr = new XMLHttpRequest();
} else {
    xhr = new ActiveXObject("Microsoft.XMLHttp");
}
xhr.open("get", "http://developer.duyiedu.com/edu/testAjaxCrossOrigin", false);
xhr.onreadystatechange = function () {
    //readyState == 4表示请求完成，已经接收到数据。
    //status == 200  网络请求，结果都会有一个状态码。来表示这个请求是否正常
    //200表示请求成功
    // http状态码
    //2**表示成功
    //3**表示重定向
    //4**表示客户端错误,404页面没找到。
    //5**表示服务端错误
    if (xhr.readyState == 4 && xhr.status == 200) {
        document.getElementById("test").innerText = xhr.responseText;
        var data = JSON.parse(xhr.responseText);
        console.log(data);
    }
}
xhr.send();//如果open第三个参数传true，或者不传，为异步模式。如果传false，为同步模式。
console.log("====");
console.log("+++");
//在计算机的世界里，异步与同步和现实世界中是相反的。
// 在计算机的世界里，同步表示串行。异步表示同时进行。可以理解为同线程和异线程。



1. 答案
（1）200：请求成功，一切正常，数据成功返回
（2）301：永久性重定向，是指所请求的文档在别的地方;文档新的URI会在定位响应头信息中给出。浏览器会自动连接到新的URI。
（3）302：临时重定向，该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。
（4）303：该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源
（5）403：Foribidden 服务器端理解本次请求，但是拒绝执行任务，没有权限访问
（6）404：NOT found 请求的资源，网页无法找到，不存在
（7）503：服务器端无法响应，服务器由于在维护或已经超载而无法响应

例2
2. 什么情况下会遇到跨域，描述一下前端常见处理跨域的几种方式。并封装一个jsonp原理。

答：
遇到跨域的情况：
协议、域名、端口，只要有一个不一样，就会发生跨域；
前端常见的处理跨域的方式：
若后端（别人家的）配合我们进行跨域 ==> 1. JSONP（正常的情况，返回的数据都是JSON格式，而JSONP是一种特殊的格式）；2. 后端设置 Access-Control-Allow_Origin 属性以支持跨域；
若后端（别人家的）不配合我们进行跨域 ==> 3. iframe （只能显示，不能控制） 如：<iframe src="http://www.baidu.com"></iframe>； 4. 通过后端代理（自己的后端）
//因为我想从一个接口获取一个数据
//但是这个接口和当前页面不是同源的。（也就是跨域了）
//但是这个接口是支持JSONP的。
//script标签，有src属性，所以可以发出网络请求
//script标签，虽然可以引用其他域的资源，浏览器不限制。
//但是，浏览器会将返回的内容，作为js代码执行。
//asd({"status":"ok","msg":"Hello! There is DuYi education!"})
//相当于调用了asd方法，传入了一个json对象作为参数。
//JSONP原理：
//1. 判断请求与当前页面的域，是否同源，如果同源则发送正常的ajax，就没有跨域的事情了。
//2. 如果不同源，生成一个script标签
//3. 生成一个随机的callback名字，还得创建一个名为这个的方法。
//4. 设置script标签的src，设置为要请求的接口。
//5. 将callback作为参数拼接在后面。
//============以上是前端部分================
//6. 后端接收到请求后，开始准备要返回的数据
//7. 后端拼接数据，将要返回的数据用callback的值和括号包裹起来
//      例如：callback=asd123456，要返回的数据为{"a":1, "b":2},
//      就要拼接为：asd123456({"a":1, "b":2});
//8. 将内容返回。
//============以上是后端部分================
//9. 浏览器接收到内容，会当做js代码来执行。
//10. 从而执行名为asd123456的方法。这样我们就接收到了后端返回给我们的对象。
var $ = {
    ajax: function (options) {
        var url = options.url;
        var type = options.type;
        var dataType = options.dataType;
        //判断是否同源（协议，域名，端口号）
        //获取目标url的域
        var targetProtocol = "";//目标接口的协议
        var targetHost = "";//目标接口的host，host是包涵域名和端口的
        //如果url不带http，那么访问的一定是相对路径，相对路径一定是同源的。
        if (url.indexOf("http://") == 0 || url.indexOf("https://") == 0) {
            var targetUrl = new URL(url);
            targetProtocol = targetUrl.protocol;
            targetHost = targetUrl.host;
        } else {
            targetProtocol = location.protocol;
            targetHost = location.host;
        }
        //首先判断是否为jsonp，因为不是jsonp不用做其他的判断，直接发送ajax
        if (dataType == "jsonp") {
            //要看是否同源
            if (location.protocol == targetProtocol && location.host == targetHost) {//表示同源
                //此处省略。因为同源，jsonp会当做普通的ajax做请求
            } else {//不同源，跨域
                //随机生成一个callback
                var callback = "cb" + Math.floor(Math.random() * 1000000);
                //给window上添加一个方法
                window[callback] = options.success;
                //生成script标签。
                var script = document.createElement("script");
                if (url.indexOf("?") > 0) {//表示已经有参数了
                    script.src = url + "&callback=" + callback;
                } else {//表示没有参数
                    script.src = url + "?callback=" + callback;
                }
                script.id = callback;
                document.head.appendChild(script);
            }
        }
    }
}
//http://developer.duyiedu.com/edu/testJsonp?callback
$.ajax({
    url: "http://developer.duyiedu.com/edu/testJsonp",
    type: "get",
    dataType: "jsonp",
    success: function (data) {
        console.log(data);
    }
});


2.  答案：
浏览器最核心，最基本的安全功能是同源策略。限制了一个源中加载文本或者脚本与其他源中资源的交互方式，当浏览器执行一个脚本时会检查是否同源，只有同源的脚本才会执行，如果不同源即为跨域。
Jsonp：原理就是利用了script标签不受同源策略的限制，在页面中动态插入了script，script标签的src属性就是后端api接口的地址，并且以get的方式将前端回调处理函数名称告诉后端，后端在响应请求时会将回调返还，并且将数据以参数的形式传递回去。
CORS：(跨域资源共享)是一种允许当前域的资源被其他域的脚本请求访问的机制。 当使用XMLHttpRequest发送请求时，浏览器如果发现违反了同源策略就会自动加上一个请求头:origin,后端在接受到请求后确定响应后会在Response Headers中加入一个属性:Access-Control-Allow-Origin,值就是发起请求的源地址，浏览器得到响应会进行判断Access-Control-Allow-Origin的值是否和当前的地址相同，只有匹配成功后才进行响应处理。现代浏览器中和移动端都支持CORS，IE下需要8+。
服务器跨域，服务器中转代理。前端向本地服务器发送请求，本地服务器代替前端再向服务器接口发送请求进行服务器间通信，本地服务器是个中转站的角色，再将响应的数据返回给前端。

例3
3. Web前端应该从哪些方面来优化网站性能。

页面级优化、代码级优化； 

参考资料：https://www.zhihu.com/question/21658448/answer/18903129

3. 答案：
减少页面体积，提升网络加载
静态资源压缩合并，（JS/css代码压缩合并，雪碧图）
静态资源缓存
使用CDN加载资源更快
优化页面渲染
css放在前面，js放后面
懒加载
减少dom操作

例4
4. 浏览器端存储有哪些，并描述他们的区别。
 
Cookie与Session

1. 如果我们用JS的变量来存数据,那么在页面关闭的时候,数据就消失了。

2. 保持登录状态是怎么做到的呢?

按照正常的HTTP协议来说,是做不到的。因为HTTP协议,上下文无关协议。

3.所以说前端页面上,有可以持久化存储数据的东西。一旦登录成功,我就记载在这个里面。
Cookie是有限制的
Cookie是存在浏览器里的,不是存在某个页面上的。是可以长期存储的。Cookie即使是保存在浏览器里,也是存放在不同的域名下的。



1,初始状态:没有登录
2,访问百度的登录,输入用户名,密码。
3,如果用户名和密码是正确的。百度的后端会向这个域名下,设置一个Cookie,写入用户的基本信息(加密的) 。
4·以后每一次向百度发送请求,浏览器都会自动带上这些Cookie.
5·服务端(后端)看到了带有ID的cookie,就可以解析这个加密的ID,来获取到这个用户本身的ID。
6,如果能获取到本身的ID,那么就证明这个用户已经登录过了。所以后端可以继续保留用户的信息
缺点:如果某个坏人,复制了我浏览器里的cookie,他就可以在他的电脑上登录我的账号了。
xsS注入攻击。




登录信息存储在服务器端
数据存在Session上也有缺点
如果用户量非常大，上亿的用户。
在用户量很大的时候，服务器端很耗资源的。
因为后端可能不止一台服务器，用户的登录信息，一般只存在一台服务器上。因为用户的登录操作，在哪台机器上执行的,就一般存在哪台机器上。
需要通过反向代理。(轮询, IP哈希。)



4.  答案：
cookie  webStorage(localStorage sessionStorage)
大小，过期时间，是否会随着http请求发送，


例5
5. 说说get和post请求。
 
5. 答案：
GET请求会被浏览器主动cache，而POST不会，除非手动设置。
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
GET请求在URL中传送的参数是有长度限制的，而POST没有。
对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
GET参数通过URL传递，POST放在Request body中。
GET产生一个TCP数据包；POST产生两个TCP数据包。（对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据））

例6
6. 一个页面从输入 URL 到页面加载完的过程中都发生了什么事情?

会解析域名，并返回对应的IP地址，随后通过返回的IP地址来访问对应的页面；

解析域名的过程：
1. 在浏览器的缓存中查找；
2. 在本机host中查找；
3. 在家里的路由器中查找；
4. 在上级路由、城市的LDNS服务器中查找；
5. 在上级的DNS服务器中查找；
6. 在gDNS服务器中查找；




6. 答案：
加载过程：
浏览器根据 DNS 服务器解析得到域名的 IP 地址
向这个 IP 的机器发送 HTTP 请求
服务器收到、处理并返回 HTTP 请求
浏览器得到返回内容
渲染过程：
根据 HTML 结构生成 DOM 树
根据 CSS 生成 CSSOM
将 DOM 和 CSSOM 整合形成 RenderTree
根据 RenderTree 开始渲染和展示
遇到<script>时，会执行并阻塞渲染

例7
7. 请描述TCP三次握手与四次挥手？

三次握手

第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

四次握手


1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。



参考资料：https://blog.csdn.net/qq_38950316/article/details/81087809

7. 答案：
三次握手：
A对B说：我的序号是x，我要向你请求连接；（第一次握手，发送SYN包，然后进入SYN-SEND状态）
B听到之后对A说：我的序号是y，期待你下一句序号是x+1的话（意思就是收到了序号为x的话，即ack=x+1），同意建立连接。（第二次握手，发送ACK-SYN包，然后进入SYN-RCVD状态）
A听到B说同意建立连接之后，对A说：与确认你同意与我连接（ack=y+1,ACK=1,seq=x+1）。（第三次握手，A已进入ESTABLISHED状态）
B听到A的确认之后，也进入ESTABLISHED状态。
四次挥手：
A与B交谈结束之后，A要结束此次会话，对B说：我要关闭连接了（seq=u,FIN=1）。（第一次挥手，A进入FIN-WAIT-1）
B收到A的消息后说：确认，你要关闭连接了。（seq=v,ack=u+1,ACK=1）（第二次挥手，B进入CLOSE-WAIT）
A收到B的确认后,等了一段时间，因为B可能还有话要对他说。（此时A进入FIN-WAIT-2）
B说完了他要说的话（只是可能还有话说）之后，对A说，我要关闭连接了。（seq=w, ack=u+1,FIN=1，ACK=1）(第三次挥手)
A收到B要结束连接的消息后说：已收到你要关闭连接的消息。（seq=u+1,ack=w+1,ACK=1）(第四次挥手，然后A进入CLOSED)
B收到A的确认后，也进入


例8
8. TCP与UDP的区别。

TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。
虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为。
对数据准确性要求高，速度可以相对较慢的，可以选用TCP。

参考资料：https://www.cnblogs.com/fundebug/p/differences-of-tcp-and-udp.html

8. 答案：
TCP：传输控制协议
UDP：用户数据报协议
区别：
TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
TCP首部开销20字节;UDP的首部开销小，只有8个字节
TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

例9
9. http是什么?

http是一种超文本传输协议，是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。http也是应用层协议，同其他应用层协议一样，是为了实现某一类具体应用的协议，并由某一运行在用户空间的应用程序来实现其功能。

9. 答案：
HTTP是hypertext transfer protocol（超文本传输协议）的简写，它是TCP/IP协议的一个应用层协议，用于定义WEB浏览器与WEB服务器之间交换数据的过程。客户端连上web服务器后，若想获得web服务器中的某个web资源，需遵守一定的通讯格式，HTTP协议用于定义客户端与web服务器通迅的格式。 

例10
10. http与https的区别。

https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。

http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。

http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
参考资料：https://www.php.cn/faq/418162.html

10. 答案：
为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。
http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

例11
11. 重排（回流）和重绘是什么?什么情况下会触发重排和重绘。

部分渲染树（或者整个渲染树）需要重新分析并且节点尺寸需要重新计算。这被称为重排。注意这里至少会有一次重排-初始化页面布局。

由于节点的几何属性发生改变或者由于样式发生改变，例如改变元素背景色时，屏幕上的部分内容需要更新。这样的更新被称为重绘。

添加、删除、更新 DOM 节点
通过 display: none 隐藏一个 DOM 节点-触发重排和重绘
通过 visibility: hidden 隐藏一个 DOM 节点-只触发重绘，因为没有几何变化
移动或者给页面中的 DOM 节点添加动画
添加一个样式表，调整样式属性
用户行为，例如调整窗口大小，改变字号，或者滚动。

11. 答案：
浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了Render Tree。有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。
回流：当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。
重绘：当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。
触发重排和重绘：
页面首次渲染
浏览器窗口大小发生改变
元素尺寸或位置发生改变
元素内容变化（文字数量或图片大小等等）
元素字体大小变化
添加或者删除可见的DOM元素
减少重回和重排：避免频繁的样式操作，最好一次性重写style，或者一次性更改class，避免频繁操作dom，对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。